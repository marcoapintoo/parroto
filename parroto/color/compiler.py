# -------------------------------------------------------------------------
#Parser.py -- ATG file parser
#Compiler Generator Coco/R,
#Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
#extended by M. Loeberbauer & A. Woess, Univ. of Linz
#ported from Java to Python by Ronald Longo
#
#This program is free software; you can redistribute it and/or modify it
#under the terms of the GNU General Public License as published by the
#Free Software Foundation; either version 2, or (at your option) any
#later version.
#
#This program is distributed in the hope that it will be useful, but
#WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
#or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
#for more details.
#
#You should have received a copy of the GNU General Public License along
#with this program; if not, write to the Free Software Foundation, Inc.,
#59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
#As an exception, it is allowed to write an extension of Coco/R that is
#used as a plugin in non-free software.
#
#If not otherwise stated, any source code generated by Coco/R (other than
#Coco/R itself) does not fall under the GNU General Public License.
#-------------------------------------------------------------------------*/

import sys

from colors import Color


class Token(object):
    def __init__(self):
        self.kind = 0  # token kind
        self.pos = 0  # token position in the source text (starting at 0)
        self.col = 0  # token column (starting at 0)
        self.line = 0  # token line (starting at 1)
        self.val = u''  # token value
        self.next = None  # AW 2003-03-07 Tokens are kept in linked list


class Position(object):  # position of source code stretch (e.g. semantic action, resolver expressions)
    def __init__(self, buf, beg, len, col):
        assert isinstance(buf, Buffer)
        assert isinstance(beg, int)
        assert isinstance(len, int)
        assert isinstance(col, int)

        self.buf = buf
        self.beg = beg  # start relative to the beginning of the file
        self.len = len  # length of stretch
        self.col = col  # column number of start position

    def getSubstring(self):
        return self.buf.readPosition(self)


class Buffer(object):
    EOF = u'\u0100'  # 256

    def __init__(self, s):
        self.buf = s
        self.bufLen = len(s)
        self.pos = 0
        self.lines = s.splitlines(True)

    def Read(self):
        if self.pos < self.bufLen:
            result = self.buf[self.pos]
            self.pos += 1
            return result
        else:
            return Buffer.EOF

    def ReadChars(self, numBytes=1):
        result = self.buf[self.pos: self.pos + numBytes]
        self.pos += numBytes
        return result

    def Peek(self):
        if self.pos < self.bufLen:
            return self.buf[self.pos]
        else:
            return Scanner.buffer.EOF

    def getString(self, beg, end):
        s = ''
        oldPos = self.getPos()
        self.setPos(beg)
        while beg < end:
            s += self.Read()
            beg += 1
        self.setPos(oldPos)
        return s

    def getPos(self):
        return self.pos

    def setPos(self, value):
        if value < 0:
            self.pos = 0
        elif value >= self.bufLen:
            self.pos = self.bufLen
        else:
            self.pos = value

    def readPosition(self, pos):
        assert isinstance(pos, Position)
        self.setPos(pos.beg)
        return self.ReadChars(pos.len)

    def __iter__(self):
        return iter(self.lines)


class Scanner(object):
    EOL = u'\n'
    eofSym = 0

    charSetSize = 256
    maxT = 29
    noSym = 29
    start = [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        4, 0, 0, 7, 0, 17, 0, 0, 18, 19, 15, 14, 28, 16, 0, 0,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 32, 0, 0, 31, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 29, 0, 30, 0, 1,
        0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 34, 1, 1, 1,
        1, 1, 1, 1, 1, 33, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        -1]
    valCh = u''  # current input character (for token.val)

    def __init__(self, s):
        self.buffer = Buffer(unicode(s))  # the buffer instance

        self.ch = u'\0'  # current input character
        self.pos = -1  # column number of current character
        self.line = 1  # line number of current character
        self.lineStart = 0  # start position of current line
        self.oldEols = 0  # EOLs that appeared in a comment;
        self.NextCh()
        self.ignore = set()  # set of characters to be ignored by the scanner
        #self.ignore.add( ord(' ') )  # blanks are always white space
        self.ignore.add(32)
        self.ignore.add(9)
        self.ignore.add(10)
        self.ignore.add(11)
        self.ignore.add(12)

        # fill token list
        self.tokens = Token()  # the complete input token stream
        node = self.tokens

        node.next = self.NextToken()
        node = node.next
        while node.kind != Scanner.eofSym:
            node.next = self.NextToken()
            node = node.next

        node.next = node
        node.val = u'EOF'
        self.t = self.tokens  # current token
        self.pt = self.tokens  # current peek token

    def NextCh(self):
        if self.oldEols > 0:
            self.ch = Scanner.EOL
            self.oldEols -= 1
        else:
            self.ch = self.buffer.Read()
            self.pos += 1
            # replace isolated '\r' by '\n' in order to make
            # eol handling uniform across Windows, Unix and Mac
            if (self.ch == u'\r') and (self.buffer.Peek() != u'\n'):
                self.ch = Scanner.EOL
            if self.ch == Scanner.EOL:
                self.line += 1
                self.lineStart = self.pos + 1
                valCh = self.ch
        if self.ch != Buffer.EOF:
            self.ch = self.ch.lower()


    def Comment0(self):
        level = 1
        line0 = self.line
        lineStart0 = self.lineStart
        self.NextCh()
        if self.ch == '*':
            self.NextCh()
            while True:
                if self.ch == '*':
                    self.NextCh()
                    if self.ch == '/':
                        level -= 1
                        if level == 0:
                            self.oldEols = self.line - line0
                            self.NextCh()
                            return True
                        self.NextCh()
                elif self.ch == Buffer.EOF:
                    return False
                else:
                    self.NextCh()
        else:
            if self.ch == Scanner.EOL:
                self.line -= 1
                self.lineStart = lineStart0
            self.pos = self.pos - 2
            self.buffer.setPos(self.pos + 1)
            self.NextCh()
        return False


    def CheckLiteral(self):
        lit = self.t.val.lower()
        if lit == "rgb":
            self.t.kind = 12
        elif lit == "rgb256":
            self.t.kind = 13
        elif lit == "uniformed_rgb":
            self.t.kind = 14
        elif lit == "linear_rgb":
            self.t.kind = 16
        elif lit == "hsl":
            self.t.kind = 18
        elif lit == "hsv":
            self.t.kind = 19
        elif lit == "cmy":
            self.t.kind = 20
        elif lit == "cmyk":
            self.t.kind = 21
        elif lit == "html":
            self.t.kind = 22
        elif lit == "hex":
            self.t.kind = 23


    def NextToken(self):
        while ord(self.ch) in self.ignore:
            self.NextCh()
        if (self.ch == '/' and self.Comment0()):
            return self.NextToken()

        self.t = Token()
        self.t.pos = self.pos
        self.t.col = self.pos - self.lineStart + 1
        self.t.line = self.line
        if ord(self.ch) < len(self.start):
            state = self.start[ord(self.ch)]
        else:
            state = 0
        buf = u''
        buf += unicode(self.ch)
        self.NextCh()

        done = False
        while not done:
            if state == -1:
                self.t.kind = Scanner.eofSym  # NextCh already done
                done = True
            elif state == 0:
                self.t.kind = Scanner.noSym  # NextCh already done
                done = True
            elif state == 1:
                if (self.ch >= '0' and self.ch <= '9'
                    or self.ch == '_'
                    or self.ch >= 'a' and self.ch <= 'z'):
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 1
                else:
                    self.t.kind = 1
                    self.t.val = buf
                    self.CheckLiteral()
                    return self.t
            elif state == 2:
                if (self.ch >= '0' and self.ch <= '9'):
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 2
                elif self.ch == '.':
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 3
                else:
                    self.t.kind = 2
                    done = True
            elif state == 3:
                if (self.ch >= '0' and self.ch <= '9'):
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 3
                else:
                    self.t.kind = 2
                    done = True
            elif state == 4:
                if (ord(self.ch) >= 9 and ord(self.ch) <= 12
                    or self.ch == ' '):
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 4
                else:
                    self.t.kind = 3
                    done = True
            elif state == 5:
                if (self.ch >= '0' and self.ch <= '9'
                    or self.ch >= 'a' and self.ch <= 'f'):
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 6
                else:
                    self.t.kind = Scanner.noSym
                    done = True
            elif state == 6:
                self.t.kind = 5
                done = True
            elif state == 7:
                if (self.ch >= '0' and self.ch <= '9'
                    or self.ch >= 'a' and self.ch <= 'f'):
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 8
                else:
                    self.t.kind = Scanner.noSym
                    done = True
            elif state == 8:
                if (self.ch >= '0' and self.ch <= '9'
                    or self.ch >= 'a' and self.ch <= 'f'):
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 9
                else:
                    self.t.kind = Scanner.noSym
                    done = True
            elif state == 9:
                if (self.ch >= '0' and self.ch <= '9'
                    or self.ch >= 'a' and self.ch <= 'f'):
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 10
                else:
                    self.t.kind = Scanner.noSym
                    done = True
            elif state == 10:
                if (self.ch >= '0' and self.ch <= '9'
                    or self.ch >= 'a' and self.ch <= 'f'):
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 11
                else:
                    self.t.kind = Scanner.noSym
                    done = True
            elif state == 11:
                if (self.ch >= '0' and self.ch <= '9'
                    or self.ch >= 'a' and self.ch <= 'f'):
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 12
                else:
                    self.t.kind = Scanner.noSym
                    done = True
            elif state == 12:
                if (self.ch >= '0' and self.ch <= '9'
                    or self.ch >= 'a' and self.ch <= 'f'):
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 13
                else:
                    self.t.kind = Scanner.noSym
                    done = True
            elif state == 13:
                if (self.ch >= '0' and self.ch <= '9'
                    or self.ch >= 'a' and self.ch <= 'f'):
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 5
                else:
                    self.t.kind = 4
                    done = True
            elif state == 14:
                self.t.kind = 6
                done = True
            elif state == 15:
                self.t.kind = 7
                done = True
            elif state == 16:
                self.t.kind = 8
                done = True
            elif state == 17:
                self.t.kind = 9
                done = True
            elif state == 18:
                self.t.kind = 10
                done = True
            elif state == 19:
                self.t.kind = 11
                done = True
            elif state == 20:
                if self.ch == 'r':
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 21
                else:
                    self.t.kind = Scanner.noSym
                    done = True
            elif state == 21:
                if self.ch == 'g':
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 22
                else:
                    self.t.kind = Scanner.noSym
                    done = True
            elif state == 22:
                if self.ch == 'b':
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 23
                else:
                    self.t.kind = Scanner.noSym
                    done = True
            elif state == 23:
                self.t.kind = 15
                done = True
            elif state == 24:
                if self.ch == 'r':
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 25
                else:
                    self.t.kind = Scanner.noSym
                    done = True
            elif state == 25:
                if self.ch == 'g':
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 26
                else:
                    self.t.kind = Scanner.noSym
                    done = True
            elif state == 26:
                if self.ch == 'b':
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 27
                else:
                    self.t.kind = Scanner.noSym
                    done = True
            elif state == 27:
                self.t.kind = 17
                done = True
            elif state == 28:
                self.t.kind = 24
                done = True
            elif state == 29:
                self.t.kind = 25
                done = True
            elif state == 30:
                self.t.kind = 26
                done = True
            elif state == 31:
                self.t.kind = 27
                done = True
            elif state == 32:
                self.t.kind = 28
                done = True
            elif state == 33:
                if (self.ch >= '0' and self.ch <= '9'
                    or self.ch == '_'
                    or self.ch >= 'a' and self.ch <= 'm'
                    or self.ch >= 'o' and self.ch <= 'z'):
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 1
                elif self.ch == 'n':
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 35
                else:
                    self.t.kind = 1
                    self.t.val = buf
                    self.CheckLiteral()
                    return self.t
            elif state == 34:
                if (self.ch >= '0' and self.ch <= '9'
                    or self.ch == '_'
                    or self.ch >= 'a' and self.ch <= 'h'
                    or self.ch >= 'j' and self.ch <= 'z'):
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 1
                elif self.ch == 'i':
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 36
                else:
                    self.t.kind = 1
                    self.t.val = buf
                    self.CheckLiteral()
                    return self.t
            elif state == 35:
                if (self.ch >= '0' and self.ch <= '9'
                    or self.ch == '_'
                    or self.ch >= 'a' and self.ch <= 'h'
                    or self.ch >= 'j' and self.ch <= 'z'):
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 1
                elif self.ch == 'i':
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 37
                else:
                    self.t.kind = 1
                    self.t.val = buf
                    self.CheckLiteral()
                    return self.t
            elif state == 36:
                if (self.ch >= '0' and self.ch <= '9'
                    or self.ch == '_'
                    or self.ch >= 'a' and self.ch <= 'm'
                    or self.ch >= 'o' and self.ch <= 'z'):
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 1
                elif self.ch == 'n':
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 38
                else:
                    self.t.kind = 1
                    self.t.val = buf
                    self.CheckLiteral()
                    return self.t
            elif state == 37:
                if (self.ch >= '0' and self.ch <= '9'
                    or self.ch == '_'
                    or self.ch >= 'a' and self.ch <= 'e'
                    or self.ch >= 'g' and self.ch <= 'z'):
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 1
                elif self.ch == 'f':
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 39
                else:
                    self.t.kind = 1
                    self.t.val = buf
                    self.CheckLiteral()
                    return self.t
            elif state == 38:
                if (self.ch >= '0' and self.ch <= '9'
                    or self.ch == '_'
                    or self.ch >= 'a' and self.ch <= 'd'
                    or self.ch >= 'f' and self.ch <= 'z'):
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 1
                elif self.ch == 'e':
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 40
                else:
                    self.t.kind = 1
                    self.t.val = buf
                    self.CheckLiteral()
                    return self.t
            elif state == 39:
                if (self.ch >= '0' and self.ch <= '9'
                    or self.ch == '_'
                    or self.ch >= 'a' and self.ch <= 'n'
                    or self.ch >= 'p' and self.ch <= 'z'):
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 1
                elif self.ch == 'o':
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 41
                else:
                    self.t.kind = 1
                    self.t.val = buf
                    self.CheckLiteral()
                    return self.t
            elif state == 40:
                if (self.ch >= '0' and self.ch <= '9'
                    or self.ch == '_'
                    or self.ch >= 'b' and self.ch <= 'z'):
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 1
                elif self.ch == 'a':
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 42
                else:
                    self.t.kind = 1
                    self.t.val = buf
                    self.CheckLiteral()
                    return self.t
            elif state == 41:
                if (self.ch >= '0' and self.ch <= '9'
                    or self.ch == '_'
                    or self.ch >= 'a' and self.ch <= 'q'
                    or self.ch >= 's' and self.ch <= 'z'):
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 1
                elif self.ch == 'r':
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 43
                else:
                    self.t.kind = 1
                    self.t.val = buf
                    self.CheckLiteral()
                    return self.t
            elif state == 42:
                if (self.ch >= '0' and self.ch <= '9'
                    or self.ch == '_'
                    or self.ch >= 'a' and self.ch <= 'q'
                    or self.ch >= 's' and self.ch <= 'z'):
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 1
                elif self.ch == 'r':
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 44
                else:
                    self.t.kind = 1
                    self.t.val = buf
                    self.CheckLiteral()
                    return self.t
            elif state == 43:
                if (self.ch >= '0' and self.ch <= '9'
                    or self.ch == '_'
                    or self.ch >= 'a' and self.ch <= 'l'
                    or self.ch >= 'n' and self.ch <= 'z'):
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 1
                elif self.ch == 'm':
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 45
                else:
                    self.t.kind = 1
                    self.t.val = buf
                    self.CheckLiteral()
                    return self.t
            elif state == 44:
                if (self.ch >= '0' and self.ch <= '9'
                    or self.ch == '_'
                    or self.ch >= 'a' and self.ch <= 'z'):
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 1
                elif self.ch == '-':
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 24
                else:
                    self.t.kind = 1
                    self.t.val = buf
                    self.CheckLiteral()
                    return self.t
            elif state == 45:
                if (self.ch >= '0' and self.ch <= '9'
                    or self.ch == '_'
                    or self.ch >= 'a' and self.ch <= 'd'
                    or self.ch >= 'f' and self.ch <= 'z'):
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 1
                elif self.ch == 'e':
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 46
                else:
                    self.t.kind = 1
                    self.t.val = buf
                    self.CheckLiteral()
                    return self.t
            elif state == 46:
                if (self.ch >= '0' and self.ch <= '9'
                    or self.ch == '_'
                    or self.ch >= 'a' and self.ch <= 'c'
                    or self.ch >= 'e' and self.ch <= 'z'):
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 1
                elif self.ch == 'd':
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 47
                else:
                    self.t.kind = 1
                    self.t.val = buf
                    self.CheckLiteral()
                    return self.t
            elif state == 47:
                if (self.ch >= '0' and self.ch <= '9'
                    or self.ch == '_'
                    or self.ch >= 'a' and self.ch <= 'z'):
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 1
                elif self.ch == '-':
                    buf += unicode(self.ch)
                    self.NextCh()
                    state = 20
                else:
                    self.t.kind = 1
                    self.t.val = buf
                    self.CheckLiteral()
                    return self.t

        self.t.val = buf
        return self.t

    def Scan(self):
        self.t = self.t.next
        self.pt = self.t.next
        return self.t

    def Peek(self):
        self.pt = self.pt.next
        while self.pt.kind > self.maxT:
            self.pt = self.pt.next

        return self.pt

    def ResetPeek(self):
        self.pt = self.t


class ErrorRec(object):
    def __init__(self, l, c, s):
        self.line = l
        self.col = c
        self.num = 0
        self.str = s


class Errors(object):
    errMsgFormat = "file %(file)s : (%(line)d, %(col)d) %(text)s\n"
    eof = False
    count = 0  # number of errors detected
    fileName = ''
    listName = ''
    mergeErrors = False
    mergedList = None  # PrintWriter
    errors = []
    minErrDist = 2
    errDist = minErrDist
    # A function with prototype: f( errorNum=None ) where errorNum is a
    # predefined error number.  f returns a tuple, ( line, column, message )
    # such that line and column refer to the location in the
    # source file most recently parsed.  message is the error
    # message corresponging to errorNum.

    @staticmethod
    def Init(fn, dir, merge, getParsingPos, errorMessages):
        Errors.theErrors = []
        Errors.getParsingPos = getParsingPos
        Errors.errorMessages = errorMessages
        Errors.fileName = fn
        listName = dir + 'listing.txt'
        Errors.mergeErrors = merge
        if Errors.mergeErrors:
            try:
                Errors.mergedList = open(listName, 'w')
            except IOError:
                raise RuntimeError('-- Compiler Error: could not open ' + listName)

    @staticmethod
    def storeError(line, col, s):
        if Errors.mergeErrors:
            Errors.errors.append(ErrorRec(line, col, s))
        else:
            Errors.printMsg(Errors.fileName, line, col, s)

    @staticmethod
    def SynErr(errNum, errPos=None):
        line, col = errPos if errPos else Errors.getParsingPos()
        msg = Errors.errorMessages[errNum]
        Errors.storeError(line, col, msg)
        Errors.count += 1

    @staticmethod
    def SemErr(errMsg, errPos=None):
        line, col = errPos if errPos else Errors.getParsingPos()
        Errors.storeError(line, col, errMsg)
        Errors.count += 1

    @staticmethod
    def Warn(errMsg, errPos=None):
        line, col = errPos if errPos else Errors.getParsingPos()
        Errors.storeError(line, col, errMsg)

    @staticmethod
    def Exception(errMsg):
        print errMsg
        sys.exit(1)

    @staticmethod
    def printMsg(fileName, line, column, msg):
        vals = {'file': fileName, 'line': line, 'col': column, 'text': msg}
        sys.stdout.write(Errors.errMsgFormat % vals)

    @staticmethod
    def display(s, e):
        Errors.mergedList.write('**** ')
        for c in xrange(1, e.col):
            if s[c - 1] == '\t':
                Errors.mergedList.write('\t')
            else:
                Errors.mergedList.write(' ')
        Errors.mergedList.write('^ ' + e.str + '\n')

    @staticmethod
    def Summarize(sourceBuffer):
        if Errors.mergeErrors:
            # Initialize the line iterator
            srcLineIter = iter(sourceBuffer)
            srcLineStr = srcLineIter.next()
            srcLineNum = 1

            try:
                # Initialize the error iterator
                errIter = iter(Errors.errors)
                errRec = errIter.next()

                # Advance to the source line of the next error
                while srcLineNum < errRec.line:
                    Errors.mergedList.write('%4d %s\n' % (srcLineNum, srcLineStr))

                    srcLineStr = srcLineIter.next()
                    srcLineNum += 1

                # Write out all errors for the current source line
                while errRec.line == srcLineNum:
                    Errors.display(srcLineStr, errRec)

                    errRec = errIter.next()
            except:
                pass

            # No more errors to report
            try:
                # Advance to end of source file
                while True:
                    Errors.mergedList.write('%4d %s\n' % (srcLineNum, srcLineStr))

                    srcLineStr = srcLineIter.next()
                    srcLineNum += 1
            except:
                pass

            Errors.mergedList.write('\n')
            Errors.mergedList.write('%d errors detected\n' % Errors.count)
            Errors.mergedList.close()

        sys.stdout.write('%d errors detected\n' % Errors.count)
        if (Errors.count > 0) and Errors.mergeErrors:
            sys.stdout.write('see ' + Errors.listName + '\n')


class Parser(object):
    _EOF = 0
    _identifier = 1
    _number = 2
    _spaces = 3
    _hexcolor = 4
    _hexalphacolor = 5
    maxT = 29

    T = True
    x = False
    minErrDist = 2

    color = None

    def __init__(self):
        self.scanner = None
        self.token = None  # last recognized token
        self.la = None  # lookahead token
        self.genScanner = False
        self.tokenString = ''  # used in declarations of literal tokens
        self.noString = '-none-'  # used in declarations of literal tokens
        self.errDist = Parser.minErrDist

    def getParsingPos(self):
        return self.la.line, self.la.col

    def SynErr(self, errNum):
        if self.errDist >= Parser.minErrDist:
            Errors.SynErr(errNum)

        self.errDist = 0

    def SemErr(self, msg):
        if self.errDist >= Parser.minErrDist:
            Errors.SemErr(msg)

        self.errDist = 0

    def Warning(self, msg):
        if self.errDist >= Parser.minErrDist:
            Errors.Warn(msg)

        self.errDist = 0

    def Successful(self):
        return Errors.count == 0;

    def LexString(self):
        return self.token.val

    def LookAheadString(self):
        return self.la.val

    def Get(self):
        while True:
            self.token = self.la
            self.la = self.scanner.Scan()
            if self.la.kind <= Parser.maxT:
                self.errDist += 1
                break

            self.la = self.token

    def Expect(self, n):
        if self.la.kind == n:
            self.Get()
        else:
            self.SynErr(n)

    def StartOf(self, s):
        return self.set[s][self.la.kind]

    def ExpectWeak(self, n, follow):
        if self.la.kind == n:
            self.Get()
        else:
            self.SynErr(n)
            while not self.StartOf(follow):
                self.Get()

    def WeakSeparator(self, n, syFol, repFol):
        s = [False for i in xrange(Parser.maxT + 1)]
        if self.la.kind == n:
            self.Get()
            return True
        elif self.StartOf(repFol):
            return False
        else:
            for i in xrange(Parser.maxT):
                s[i] = self.set[syFol][i] or self.set[repFol][i] or self.set[0][i]
            self.SynErr(n)
            while not s[self.la.kind]:
                self.Get()
            return self.StartOf(syFol)

    def Syntax(self):
        color = None;
        color = self.ColorOperation()
        self.Expect(0)
        self.color = color

    def ColorOperation(self):
        color = None;
        other = None;
        color = self.Color()
        while self.la.kind == 6 or self.la.kind == 7 or self.la.kind == 8:
            if self.la.kind == 6:
                other = self.AddingColor()
                color = color.add(other);
            else:
                other = self.MultiplyingColor()
                color = color.multiply(other);

        return color

    def Color(self):
        color = Color();
        value = 0;
        if self.la.kind == 2:
            value = self.Percentage()
            color.modify("percentage", value);
            self.BaseColor(color)
        elif self.StartOf(1):
            self.BaseColor(color)
        else:
            self.SynErr(30)
        return color

    def AddingColor(self):
        self.Expect(6)
        color = self.ColorOperation()
        return color

    def MultiplyingColor(self):
        if self.la.kind == 7:
            self.Get()
        elif self.la.kind == 8:
            self.Get()
        else:
            self.SynErr(31)
        color = self.ColorOperation()
        return color

    def Percentage(self):
        self.Expect(2)
        value = float(self.token.val) / 100.0;
        self.Expect(9)
        return value

    def BaseColor(self, color):
        if self.StartOf(2):
            self.ColorDefinition(color)
        elif self.la.kind == 1 or self.la.kind == 10 or self.la.kind == 25:
            self.NamedColor(color)
        else:
            self.SynErr(32)

    def ColorDefinition(self, color):
        if self.StartOf(3):
            self.ColorFormatNumeric()
            format = self.token.val;
            if self.la.kind == 2:
                self.ColorParametersNumeric(color, format)
            elif self.la.kind == 10:
                self.Get()
                self.ColorParametersNumeric(color, format)
                self.Expect(11)
            else:
                self.SynErr(33)
        elif self.la.kind == 22 or self.la.kind == 23:
            self.ColorFormatHexColor()
            if self.la.kind == 4 or self.la.kind == 5:
                self.ColorParametersHexColor(color)
            elif self.la.kind == 10:
                self.Get()
                self.ColorParametersHexColor(color)
                self.Expect(11)
            else:
                self.SynErr(34)
        else:
            self.SynErr(35)

    def NamedColor(self, color):
        if self.la.kind == 1 or self.la.kind == 25:
            self.ColorParametersNamedColor(color)
        elif self.la.kind == 10:
            self.Get()
            self.ColorParametersNamedColor(color)
            self.Expect(11)
        else:
            self.SynErr(36)

    def ColorParametersNamedColor(self, color):
        name = ""
        name = self.ColorName()
        color.named_color(name)
        while self.la.kind == 1 or self.la.kind == 24:
            while self.la.kind == 24:
                self.Get()

            self.ColorModifier(color)


    def ColorFormatNumeric(self):
        if self.la.kind == 12:
            self.Get()
        elif self.la.kind == 13:
            self.Get()
        elif self.la.kind == 14:
            self.Get()
        elif self.la.kind == 15:
            self.Get()
        elif self.la.kind == 16:
            self.Get()
        elif self.la.kind == 17:
            self.Get()
        elif self.la.kind == 18:
            self.Get()
        elif self.la.kind == 19:
            self.Get()
        elif self.la.kind == 20:
            self.Get()
        elif self.la.kind == 21:
            self.Get()
        else:
            self.SynErr(37)

    def ColorParametersNumeric(self, color, format):
        self.Expect(2)
        value = [float(self.token.val)]
        while self.la.kind == 2 or self.la.kind == 24:
            while self.la.kind == 24:
                self.Get()

            self.Get()
            value.append(float(self.token.val))

        color.set_value(value, format)
        while self.la.kind == 1 or self.la.kind == 24:
            while self.la.kind == 24:
                self.Get()

            self.ColorModifier(color)


    def ColorFormatHexColor(self):
        if self.la.kind == 22:
            self.Get()
        elif self.la.kind == 23:
            self.Get()
        else:
            self.SynErr(38)

    def ColorParametersHexColor(self, color):
        if self.la.kind == 4:
            self.Get()
        elif self.la.kind == 5:
            self.Get()
        else:
            self.SynErr(39)
        color.set_value(eval(self.token.val), "hex")
        while self.la.kind == 1 or self.la.kind == 24:
            while self.la.kind == 24:
                self.Get()

            self.ColorModifier(color)


    def ColorModifier(self, color):
        name = "";
        value = "";
        self.Expect(1)
        name = self.token.val;
        if (self.la.kind == 27 or self.la.kind == 28):
            if self.la.kind == 27:
                self.Get()
            else:
                self.Get()
            if self.la.kind == 2:
                self.Get()
                value = float(self.token.val);
            elif self.la.kind == 1:
                self.Get()
                value = self.token.val;
            else:
                self.SynErr(40)
        color.modify(name, value);

    def ColorName(self):
        name = ""
        if self.la.kind == 1:
            self.Get()
            name = self.token.val;
        elif self.la.kind == 25:
            self.Get()
            while self.StartOf(4):
                self.Get()
                name += self.token.val;

            self.Expect(26)
        else:
            self.SynErr(41)
        return name


    def Parse(self, scanner):
        self.scanner = scanner
        self.la = Token()
        self.la.val = u''
        self.Get()
        self.Syntax()
        self.Expect(0)


    set = [
        [T, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x],
        [x, T, x, x, x, x, x, x, x, x, T, x, T, T, T, T, T, T, T, T, T, T, T, T, x, T, x, x, x, x, x],
        [x, x, x, x, x, x, x, x, x, x, x, x, T, T, T, T, T, T, T, T, T, T, T, T, x, x, x, x, x, x, x],
        [x, x, x, x, x, x, x, x, x, x, x, x, T, T, T, T, T, T, T, T, T, T, x, x, x, x, x, x, x, x, x],
        [x, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, x, T, T, T, x]

    ]

    errorMessages = {

        0: "EOF expected",
        1: "identifier expected",
        2: "number expected",
        3: "spaces expected",
        4: "hexcolor expected",
        5: "hexalphacolor expected",
        6: "\"+\" expected",
        7: "\"*\" expected",
        8: "\"-\" expected",
        9: "\"%\" expected",
        10: "\"(\" expected",
        11: "\")\" expected",
        12: "\"rgb\" expected",
        13: "\"rgb256\" expected",
        14: "\"uniformed_rgb\" expected",
        15: "\"uniformed-rgb\" expected",
        16: "\"linear_rgb\" expected",
        17: "\"linear-rgb\" expected",
        18: "\"hsl\" expected",
        19: "\"hsv\" expected",
        20: "\"cmy\" expected",
        21: "\"cmyk\" expected",
        22: "\"html\" expected",
        23: "\"hex\" expected",
        24: "\",\" expected",
        25: "\"[\" expected",
        26: "\"]\" expected",
        27: "\"=\" expected",
        28: "\":\" expected",
        29: "??? expected",
        30: "invalid Color",
        31: "invalid MultiplyingColor",
        32: "invalid BaseColor",
        33: "invalid ColorDefinition",
        34: "invalid ColorDefinition",
        35: "invalid ColorDefinition",
        36: "invalid NamedColor",
        37: "invalid ColorFormatNumeric",
        38: "invalid ColorFormatHexColor",
        39: "invalid ColorParametersHexColor",
        40: "invalid ColorModifier",
        41: "invalid ColorName",
    }


