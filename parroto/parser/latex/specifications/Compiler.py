#-------------------------------------------------------------------------
#Parser.py -- ATG file parser
#Compiler Generator Coco/R,
#Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
#extended by M. Loeberbauer & A. Woess, Univ. of Linz
#ported from Java to Python by Ronald Longo
#
#This program is free software; you can redistribute it and/or modify it
#under the terms of the GNU General Public License as published by the
#Free Software Foundation; either version 2, or (at your option) any
#later version.
#
#This program is distributed in the hope that it will be useful, but
#WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
#or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
#for more details.
#
#You should have received a copy of the GNU General Public License along
#with this program; if not, write to the Free Software Foundation, Inc.,
#59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
#As an exception, it is allowed to write an extension of Coco/R that is
#used as a plugin in non-free software.
#
#If not otherwise stated, any source code generated by Coco/R (other than
#Coco/R itself) does not fall under the GNU General Public License.
#-------------------------------------------------------------------------*/

from Macro import Node

import sys

from Scanner import Token
from Scanner import Scanner
from Scanner import Position

class ErrorRec( object ):
   def __init__( self, l, c, s ):
      self.line   = l
      self.col    = c
      self.num    = 0
      self.str    = s


class Errors( object ):
   errMsgFormat = "file %(file)s : (%(line)d, %(col)d) %(text)s\n"
   eof          = False
   count        = 0         # number of errors detected
   fileName     = ''
   listName     = ''
   mergeErrors  = False
   mergedList   = None      # PrintWriter
   errors       = [ ]
   minErrDist   = 2
   errDist      = minErrDist
      # A function with prototype: f( errorNum=None ) where errorNum is a
      # predefined error number.  f returns a tuple, ( line, column, message )
      # such that line and column refer to the location in the
      # source file most recently parsed.  message is the error
      # message corresponging to errorNum.

   @staticmethod
   def Init( fn, dir, merge, getParsingPos, errorMessages ):
      Errors.theErrors = [ ]
      Errors.getParsingPos = getParsingPos
      Errors.errorMessages = errorMessages
      Errors.fileName = fn
      listName = dir + 'listing.txt'
      Errors.mergeErrors = merge
      if Errors.mergeErrors:
         try:
            Errors.mergedList = open( listName, 'w' )
         except IOError:
            raise RuntimeError( '-- Compiler Error: could not open ' + listName )

   @staticmethod
   def storeError( line, col, s ):
      if Errors.mergeErrors:
         Errors.errors.append( ErrorRec( line, col, s ) )
      else:
         Errors.printMsg( Errors.fileName, line, col, s )

   @staticmethod
   def SynErr( errNum, errPos=None ):
      line,col = errPos if errPos else Errors.getParsingPos( )
      msg = Errors.errorMessages[ errNum ]
      Errors.storeError( line, col, msg )
      Errors.count += 1

   @staticmethod
   def SemErr( errMsg, errPos=None ):
      line,col = errPos if errPos else Errors.getParsingPos( )
      Errors.storeError( line, col, errMsg )
      Errors.count += 1

   @staticmethod
   def Warn( errMsg, errPos=None ):
      line,col = errPos if errPos else Errors.getParsingPos( )
      Errors.storeError( line, col, errMsg )

   @staticmethod
   def Exception( errMsg ):
      print errMsg
      sys.exit( 1 )

   @staticmethod
   def printMsg( fileName, line, column, msg ):
      vals = { 'file':fileName, 'line':line, 'col':column, 'text':msg }
      sys.stdout.write( Errors.errMsgFormat % vals )

   @staticmethod
   def display( s, e ):
      Errors.mergedList.write('**** ')
      for c in xrange( 1, e.col ):
         if s[c-1] == '\t':
            Errors.mergedList.write( '\t' )
         else:
            Errors.mergedList.write( ' ' )
      Errors.mergedList.write( '^ ' + e.str + '\n')

   @staticmethod
   def Summarize( sourceBuffer ):
      if Errors.mergeErrors:
         # Initialize the line iterator
         srcLineIter = iter(sourceBuffer)
         srcLineStr  = srcLineIter.next( )
         srcLineNum  = 1

         try:
            # Initialize the error iterator
            errIter = iter(Errors.errors)
            errRec  = errIter.next( )

            # Advance to the source line of the next error
            while srcLineNum < errRec.line:
               Errors.mergedList.write( '%4d %s\n' % (srcLineNum, srcLineStr) )

               srcLineStr = srcLineIter.next( )
               srcLineNum += 1

            # Write out all errors for the current source line
            while errRec.line == srcLineNum:
               Errors.display( srcLineStr, errRec )

               errRec = errIter.next( )
         except:
            pass

         # No more errors to report
         try:
            # Advance to end of source file
            while True:
               Errors.mergedList.write( '%4d %s\n' % (srcLineNum, srcLineStr) )

               srcLineStr = srcLineIter.next( )
               srcLineNum += 1
         except:
            pass

         Errors.mergedList.write( '\n' )
         Errors.mergedList.write( '%d errors detected\n' % Errors.count )
         Errors.mergedList.close( )

      sys.stdout.write( '%d errors detected\n' % Errors.count )
      if (Errors.count > 0) and Errors.mergeErrors:
         sys.stdout.write( 'see ' + Errors.listName + '\n' )


class Parser( object ):
   _EOF = 0
   _identifier = 1
   _number = 2
   _numunit = 3
   _spaces = 4
   maxT = 42

   T          = True
   x          = False
   minErrDist = 2

   document = None
   def isCommandToken(self):
        token = self.token.next
        posttoken = self.token.next.next
        return token.val=="@" and posttoken.val not in ["end", "End", "END"]
   def isAnyToken(self):
        token = self.token.next
        print "TOKEN:", token.val
        

   def __init__( self ):
      self.scanner     = None
      self.token       = None           # last recognized token
      self.la          = None           # lookahead token
      self.genScanner  = False
      self.tokenString = ''             # used in declarations of literal tokens
      self.noString    = '-none-'       # used in declarations of literal tokens
      self.errDist     = Parser.minErrDist

   def getParsingPos( self ):
      return self.la.line, self.la.col

   def SynErr( self, errNum ):
      if self.errDist >= Parser.minErrDist:
         Errors.SynErr( errNum )

      self.errDist = 0

   def SemErr( self, msg ):
      if self.errDist >= Parser.minErrDist:
         Errors.SemErr( msg )

      self.errDist = 0

   def Warning( self, msg ):
      if self.errDist >= Parser.minErrDist:
         Errors.Warn( msg )

      self.errDist = 0

   def Successful( self ):
      return Errors.count == 0;

   def LexString( self ):
      return self.token.val

   def LookAheadString( self ):
      return self.la.val

   def Get( self ):
      while True:
         self.token = self.la
         self.la = self.scanner.Scan( )
         if self.la.kind <= Parser.maxT:
            self.errDist += 1
            break
         
         self.la = self.token

   def Expect( self, n ):
      if self.la.kind == n:
         self.Get( )
      else:
         self.SynErr( n )

   def StartOf( self, s ):
      return self.set[s][self.la.kind]

   def ExpectWeak( self, n, follow ):
      if self.la.kind == n:
         self.Get( )
      else:
         self.SynErr( n )
         while not self.StartOf(follow):
            self.Get( )

   def WeakSeparator( self, n, syFol, repFol ):
      s = [ False for i in xrange( Parser.maxT+1 ) ]
      if self.la.kind == n:
         self.Get( )
         return True
      elif self.StartOf(repFol):
         return False
      else:
         for i in xrange( Parser.maxT ):
            s[i] = self.set[syFol][i] or self.set[repFol][i] or self.set[0][i]
         self.SynErr( n )
         while not s[self.la.kind]:
            self.Get( )
         return self.StartOf( syFol )

   def string( self ):
      val = "" 
      if self.la.kind == 5:
         self.Get( )
         val += self.token.val 
         while self.StartOf(1):
            if self.StartOf(2):
               self.Get()
               val += self.token.val 
            elif self.la.kind == 4:
               self.Get( )
               val += self.token.val 
            else:
               self.Get( )
               val += self.token.val 

         self.Get( )
         val += self.token.val 
      elif self.la.kind == 7:
         self.Get( )
         val += self.token.val 
         while self.StartOf(3):
            if self.StartOf(4):
               self.Get()
               val += self.token.val 
            elif self.la.kind == 4:
               self.Get( )
               val += self.token.val 
            else:
               self.Get( )
               val += self.token.val 

         self.Get( )
         val += self.token.val 
      else:
         self.SynErr(43)
      return val

   def MacroSyntax( self ):
      doc = Node.CreateDocument(); cmd = None; txt = ""; 
      while self.StartOf(5):
         if self.la.kind == 10:
            cmd = self.Command()
            if txt != "": doc.AddTextChild(txt) 
            doc.AddChild(cmd); txt = "" 
         elif self.la.kind == 4:
            self.Get( )
            txt += self.token.val; 
         elif self.la.kind == 9:
            self.Get( )
            txt += "@"; 
         else:
            #if self.isAnyToken(): break 
            self.Get()
            txt += self.token.val; 

      self.Expect(0)
      if txt != "": doc.AddTextChild(txt) 
      self.document = doc; 
      #self.document.ViewTreeForm() 

   def Command( self ):
      cmd = None 
      self.Expect(10)
      while not (self.StartOf(6)):
         self.SynErr(44)
         self.Get()
      if (self.la.kind == 4):
         self.Get( )
      if self.la.kind == 1 or self.la.kind == 18:
         cmd = self.SimpleCommand()
      elif self.la.kind == 11 or self.la.kind == 12 or self.la.kind == 13:
         cmd = self.ExtendedCommand()
      else:
         self.SynErr(45)
      return cmd

   def SimpleCommand( self ):
      cmd = Node(); spaceval=""; textcmd = None
      temp = self.CommandName()
      cmd.name = temp.replace("_", "") 
      if (self.la.kind == 4):
         self.Get( )
         spaceval = self.token.val 
      if (self.la.kind == 20):
         self.ArgumentExpression(cmd)
         spaceval = "" 
      if (self.la.kind == 4):
         self.Get( )
         spaceval = self.token.val 
      if (self.la.kind == 18):
         self.TextArguments(cmd)
         spaceval = ""; 
      cmd.AddTextChild(spaceval); 
      return cmd

   def ExtendedCommand( self ):
      cmd = Node(); spaceval=""; textcmd = None; txt = ""
      self.BeginToken()
      if (self.la.kind == 4):
         self.Get( )
      temp = self.CommandName()
      cmd.name = temp.replace("_", ""); 
      if (self.la.kind == 4):
         self.Get( )
      if (self.la.kind == 20):
         self.ArgumentExpression(cmd)
      while self.StartOf(5):
         if self.StartOf(7):
            self.Get()
            txt += self.token.val; 
         elif self.la.kind == 4:
            self.Get( )
            txt += self.token.val; 
         elif self.la.kind == 9:
            self.Get( )
            txt += "@"; 
         else:
            if not self.isCommandToken(): break 
            temp = self.Command()
            if txt != "": cmd.AddTextChild(txt) 
            txt = ""; cmd.AddChild(temp); 

      if txt != "": cmd.AddTextChild(txt) 
      self.Expect(10)
      if (self.la.kind == 4):
         self.Get( )
      self.EndToken()
      return cmd

   def CommandName( self ):
      value = ""; id = "" 
      if self.la.kind == 1:
         id = self.Identifier()
         value += id 
      elif self.la.kind == 18:
         self.Get( )
         id = self.Identifier()
         value += id 
         self.Expect(19)
      else:
         self.SynErr(46)
      return value

   def ArgumentExpression( self, macro ):
      self.Expect(20)
      if (self.la.kind == 4):
         self.Get( )
      if (self.StartOf(8)):
         self.ArgumentParameters(macro)
      if (self.la.kind == 4):
         self.Get( )
      self.Expect(21)
      if (self.la.kind == 4):
         self.Get( )

   def TextArguments( self, cmd ):
      txt = ""
      self.Expect(18)
      if (self.la.kind == 4):
         self.Get( )
         txt += self.token.val; 
      while self.StartOf(9):
         if self.StartOf(10):
            self.Get()
            txt += self.token.val; 
         elif self.la.kind == 25:
            self.Get( )
            txt += self.token.val; 
         elif self.la.kind == 9:
            self.Get( )
            txt += "@"; 
         elif self.la.kind == 4:
            self.Get( )
            txt += self.token.val; 
         else:
            cmd = self.Command()
            if txt != "": cmd.AddTextChild(txt) 
            txt = ""; cmd.AddChild(cmd); 

      if txt != "": cmd.AddTextChild(txt) 
      self.Expect(19)

   def BeginToken( self ):
      if self.la.kind == 11:
         self.Get( )
      elif self.la.kind == 12:
         self.Get( )
      elif self.la.kind == 13:
         self.Get( )
      else:
         self.SynErr(47)
      if (self.la.kind == 4):
         self.Get( )
      self.Expect(14)

   def EndToken( self ):
      if self.la.kind == 15:
         self.Get( )
      elif self.la.kind == 16:
         self.Get( )
      elif self.la.kind == 17:
         self.Get( )
      else:
         self.SynErr(48)

   def Identifier( self ):
      value = "" 
      self.Expect(1)
      value += self.token.val 
      while self.la.kind == 14:
         self.Get( )
         value += "_" 
         self.Expect(1)
         value += self.token.val 

      return value

   def ArgumentParameters( self, macro ):
      uparams = []; nparams = {}; name=""; expr=""; 
      name = self.CommonExpression()
      uparams.append(name);  
      if (self.la.kind == 4):
         self.Get( )
      if (self.la.kind == 22 or self.la.kind == 23):
         if self.la.kind == 22:
            self.Get( )
         else:
            self.Get( )
         if (self.la.kind == 4):
            self.Get( )
         expr = self.CommonExpression()
         nparams[name] = expr; uparams.pop(); 
      if (self.la.kind == 4):
         self.Get( )
      while self.StartOf(11):
         while self.la.kind == 24:
            self.Get( )

         if (self.la.kind == 4):
            self.Get( )
         name = self.CommonExpression()
         uparams.append(name) 
         if (self.la.kind == 4):
            self.Get( )
         if (self.la.kind == 22 or self.la.kind == 23):
            if self.la.kind == 22:
               self.Get( )
            else:
               self.Get( )
            if (self.la.kind == 4):
               self.Get( )
            expr = self.CommonExpression()
            nparams[name] = expr; uparams.pop(); 
         if (self.la.kind == 4):
            self.Get( )

      if (self.la.kind == 4):
         self.Get( )
      for index, key in enumerate(uparams): nparams[index] = key 
      for key in nparams:
          attr = Node.CreateAttribute(); 
          attr.order = 0 
          attr.AddTextChild(nparams[key]) 
          macro.AddAttribute(str(key), attr) 

   def CommonExpression( self ):
      expression = ""; expr = ""; 
      expr = self.XorExpression()
      expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      while self.la.kind == 26:
         self.Get( )
         expression += " or "; 
         if (self.la.kind == 4):
            self.Get( )
         expr = self.XorExpression()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )

      if (self.la.kind == 4):
         self.Get( )
      return expression

   def XorExpression( self ):
      expression = ""; expr = ""; 
      expr = self.AndExpression()
      expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      while self.la.kind == 27:
         self.Get( )
         expression += " xor "; 
         if (self.la.kind == 4):
            self.Get( )
         expr = self.AndExpression()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )

      if (self.la.kind == 4):
         self.Get( )
      return expression

   def AndExpression( self ):
      expression = ""; expr = ""; 
      expr = self.ArithmeticExpression()
      expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      while self.la.kind == 28:
         self.Get( )
         expression += " and "; 
         if (self.la.kind == 4):
            self.Get( )
         expr = self.ArithmeticExpression()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )

      return expression

   def ArithmeticExpression( self ):
      expression = ""; expr = ""; 
      expr = self.TermExpression()
      expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      while self.la.kind == 14 or self.la.kind == 29:
         if self.la.kind == 29:
            self.Get( )
         else:
            self.Get( )
         expression += " " + self.token.val + " "; 
         if (self.la.kind == 4):
            self.Get( )
         expr = self.TermExpression()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )

      if (self.la.kind == 4):
         self.Get( )
      return expression

   def TermExpression( self ):
      expression = ""; expr = ""; 
      expr = self.FactorTerm()
      expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      while self.StartOf(12):
         if self.la.kind == 30:
            self.Get( )
         elif self.la.kind == 31:
            self.Get( )
         elif self.la.kind == 32:
            self.Get( )
         else:
            self.Get( )
         expression += " " + self.token.val +  " "; 
         if (self.la.kind == 4):
            self.Get( )
         expr = self.FactorTerm()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )

      if (self.la.kind == 4):
         self.Get( )
      return expression

   def FactorTerm( self ):
      expression = ""; expr = ""; 
      if self.la.kind == 14 or self.la.kind == 29 or self.la.kind == 34:
         expr = self.UnaryTerm()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )
      elif self.StartOf(13):
         expr = self.PowerTerm()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )
      else:
         self.SynErr(49)
      return expression

   def UnaryTerm( self ):
      expression = ""; expr = "";
      if self.la.kind == 29:
         self.Get( )
      elif self.la.kind == 14:
         self.Get( )
      elif self.la.kind == 34:
         self.Get( )
      else:
         self.SynErr(50)
      expression += " " + self.token.val + " "; 
      if (self.la.kind == 4):
         self.Get( )
      expr = self.FactorTerm()
      expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      return expression

   def PowerTerm( self ):
      expression = ""; expr = "";
      if self.StartOf(14):
         expr = self.MinimumTerm()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )
      elif self.StartOf(15):
         expr = self.AtomNonTrailableTerm()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )
      else:
         self.SynErr(51)
      return expression

   def MinimumTerm( self ):
      expression = ""; expr = ""; 
      expr = self.AtomTrailableTerm()
      expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      while self.la.kind == 20 or self.la.kind == 36 or self.la.kind == 41:
         expr = self.TrailerTerm()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )

      if (self.la.kind == 35):
         self.Get( )
         expression += " " + self.token.val + " "; 
         if (self.la.kind == 4):
            self.Get( )
         expr = self.FactorTerm()
         expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      return expression

   def AtomNonTrailableTerm( self ):
      expression = ""; expr = ""; 
      if self.la.kind == 2:
         self.Get( )
         expression += " " + self.token.val + " "; 
         if (self.la.kind == 4):
            self.Get( )
      elif self.la.kind == 3:
         self.Get( )
         expression += UnitNumber(self.token.val).EvalString() 
         if (self.la.kind == 4):
            self.Get( )
      elif self.la.kind == 38:
         self.Get( )
         expression += " " + self.token.val + " " 
         if (self.la.kind == 4):
            self.Get( )
      elif self.la.kind == 39:
         self.Get( )
         expression += " " + self.token.val + " " 
         if (self.la.kind == 4):
            self.Get( )
      elif self.la.kind == 40:
         self.Get( )
         expression += " " + self.token.val + " " 
         if (self.la.kind == 4):
            self.Get( )
      else:
         self.SynErr(52)
      return expression

   def AtomTrailableTerm( self ):
      expression = ""; expr = ""; 
      if self.la.kind == 36:
         expr = self.ListExpression()
         expression += expr; 
      elif self.la.kind == 18:
         expr = self.DictExpression()
         expression += expr; 
      elif self.la.kind == 20:
         expr = self.TupleExpression()
         expression += expr; 
      elif self.la.kind == 1:
         expr = self.Identifier()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )
      elif self.la.kind == 5 or self.la.kind == 7:
         expr = self.string()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )
      else:
         self.SynErr(53)
      return expression

   def TrailerTerm( self ):
      expression = ""; expr = ""; 
      if self.la.kind == 20:
         expr = self.CallExpression()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )
      elif self.la.kind == 36:
         expr = self.Indexer()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )
      elif self.la.kind == 41:
         self.Get( )
         expression += "."; 
         if (self.la.kind == 4):
            self.Get( )
         expr = self.Identifier()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )
      else:
         self.SynErr(54)
      return expression

   def ListExpression( self ):
      expression = ""; expr = ""; 
      self.Expect(36)
      expression += "["; 
      if (self.la.kind == 4):
         self.Get( )
      if (self.StartOf(8)):
         expr = self.ListElements()
         expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      self.Expect(37)
      expression += "]"; 
      return expression

   def ListElements( self ):
      expression = ""; expr = ""; 
      expr = self.CommonExpression()
      expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      while self.StartOf(11):
         while self.la.kind == 24:
            self.Get( )

         expression += ","; 
         if (self.la.kind == 4):
            self.Get( )
         expr = self.CommonExpression()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )

      if (self.la.kind == 4):
         self.Get( )
      while self.la.kind == 24:
         self.Get( )
         if (self.la.kind == 4):
            self.Get( )

      if (self.la.kind == 4):
         self.Get( )
      return expression

   def DictExpression( self ):
      expression = ""; expr = ""; 
      self.Expect(18)
      expression += "{"; 
      if (self.la.kind == 4):
         self.Get( )
      if (self.StartOf(16)):
         expr = self.DictionaryElements()
         expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      self.Expect(19)
      expression += "}"; 
      return expression

   def DictionaryElements( self ):
      expression = ""; expr = ""; 
      expr = self.DictionaryElementKey()
      expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      if self.la.kind == 22:
         self.Get( )
      elif self.la.kind == 23:
         self.Get( )
      else:
         self.SynErr(55)
      expression += ":"; 
      if (self.la.kind == 4):
         self.Get( )
      expr = self.CommonExpression()
      expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      while self.StartOf(17):
         while self.la.kind == 24:
            self.Get( )

         expression += ","; 
         if (self.la.kind == 4):
            self.Get( )
         expr = self.DictionaryElementKey()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )
         if self.la.kind == 22:
            self.Get( )
         elif self.la.kind == 23:
            self.Get( )
         else:
            self.SynErr(56)
         expression += ":"; 
         if (self.la.kind == 4):
            self.Get( )
         expr = self.CommonExpression()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )

      if (self.la.kind == 4):
         self.Get( )
      return expression

   def TupleExpression( self ):
      expression = ""; expr = ""; 
      self.Expect(20)
      expression += "("; 
      if (self.la.kind == 4):
         self.Get( )
      if (self.StartOf(8)):
         expr = self.ListElements()
         expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      self.Expect(21)
      expression += ")"; 
      return expression

   def CallParametersElements( self ):
      expression = ""; expr = ""; 
      expr = self.Identifier()
      expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      if self.la.kind == 22:
         self.Get( )
      elif self.la.kind == 23:
         self.Get( )
      else:
         self.SynErr(57)
      expression += ":"; 
      if (self.la.kind == 4):
         self.Get( )
      expr = self.CommonExpression()
      expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      while self.la.kind == 1 or self.la.kind == 4 or self.la.kind == 24:
         while self.la.kind == 24:
            self.Get( )

         expression += ","; 
         if (self.la.kind == 4):
            self.Get( )
         expr = self.Identifier()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )
         if self.la.kind == 22:
            self.Get( )
         elif self.la.kind == 23:
            self.Get( )
         else:
            self.SynErr(58)
         expression += ":"; 
         if (self.la.kind == 4):
            self.Get( )
         expr = self.CommonExpression()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )

      if (self.la.kind == 4):
         self.Get( )
      return expression

   def DictionaryElementKey( self ):
      expression = ""; expr = ""; 
      if self.la.kind == 1:
         expr = self.Identifier()
         expression += repr(expr); 
      elif self.la.kind == 5 or self.la.kind == 7:
         expr = self.string()
         expression += expr; 
      elif self.la.kind == 2:
         self.Get( )
         expression += self.token.val; 
      else:
         self.SynErr(59)
      return expression

   def CallExpression( self ):
      expression = ""; expr = ""; 
      self.Expect(20)
      expression += "("; 
      if (self.la.kind == 4):
         self.Get( )
      if (self.StartOf(8)):
         expr = self.ListElements()
         expression += expr; 
      if (self.la.kind == 1):
         expr = self.CallParametersElements()
         expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      self.Expect(21)
      if (self.la.kind == 4):
         self.Get( )
      return expression

   def Indexer( self ):
      expression = ""; expr = ""; 
      self.Expect(36)
      expression += "["; 
      if (self.la.kind == 4):
         self.Get( )
      expr = self.SubscriptList()
      expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      self.Expect(37)
      expression += "]"; 
      if (self.la.kind == 4):
         self.Get( )
      return expression

   def SubscriptList( self ):
      expression = ""; expr = ""; 
      expr = self.SubscriptElement()
      expression += expr; 
      while self.StartOf(18):
         while self.la.kind == 24:
            self.Get( )

         expression += ","; 
         expr = self.SubscriptElement()
         expression += expr; 

      while self.la.kind == 24:
         self.Get( )

      return expression

   def SubscriptElement( self ):
      expression = ""; expr = ""; 
      expr = self.CommonExpression()
      expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      if (self.la.kind == 22):
         self.Get( )
         expression += ":"; 
         if (self.la.kind == 4):
            self.Get( )
         if (self.StartOf(8)):
            expr = self.CommonExpression()
            expression += expr; 
            if (self.la.kind == 4):
               self.Get( )
         if (self.la.kind == 22):
            self.Get( )
            expression += ":"; 
            if (self.la.kind == 4):
               self.Get( )
            if (self.StartOf(8)):
               expr = self.CommonExpression()
               expression += expr; 
               if (self.la.kind == 4):
                  self.Get( )
      return expression



   def Parse( self, scanner ):
      self.scanner = scanner
      self.la = Token( )
      self.la.val = u''
      self.Get( )
      self.MacroSyntax()
      self.Expect(0)


   set = [
      [T,T,x,x, T,x,x,x, x,x,x,T, T,T,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x],
      [x,T,T,T, T,x,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,x],
      [x,T,T,T, x,x,x,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,x],
      [x,T,T,T, T,T,T,x, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,x],
      [x,T,T,T, x,T,T,x, x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,x],
      [x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,x],
      [T,T,x,x, T,x,x,x, x,x,x,T, T,T,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x],
      [x,T,T,T, x,T,T,T, T,x,x,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,x],
      [x,T,T,T, x,T,x,T, x,x,x,x, x,x,T,x, x,x,T,x, T,x,x,x, x,x,x,x, x,T,x,x, x,x,T,x, T,x,T,T, T,x,x,x],
      [x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,x, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,x],
      [x,T,T,T, x,T,T,T, T,x,x,T, T,T,T,T, T,T,T,x, T,T,T,T, T,x,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,x],
      [x,T,T,T, T,T,x,T, x,x,x,x, x,x,T,x, x,x,T,x, T,x,x,x, T,x,x,x, x,T,x,x, x,x,T,x, T,x,T,T, T,x,x,x],
      [x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,T,x,x, x,x,x,x, x,x,x,x],
      [x,T,T,T, x,T,x,T, x,x,x,x, x,x,x,x, x,x,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,T,T, T,x,x,x],
      [x,T,x,x, x,T,x,T, x,x,x,x, x,x,x,x, x,x,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x],
      [x,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,x,x,x],
      [x,T,T,x, x,T,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x],
      [x,T,T,x, T,T,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x],
      [x,T,T,T, x,T,x,T, x,x,x,x, x,x,T,x, x,x,T,x, T,x,x,x, T,x,x,x, x,T,x,x, x,x,T,x, T,x,T,T, T,x,x,x]

      ]

   errorMessages = {
      
      0 : "EOF expected",
      1 : "identifier expected",
      2 : "number expected",
      3 : "numunit expected",
      4 : "spaces expected",
      5 : "\"\'\" expected",
      6 : "\"\\\\\'\" expected",
      7 : "\"\"\" expected",
      8 : "\"\\\\\"\" expected",
      9 : "\"\\\\@\" expected",
      10 : "\"@\" expected",
      11 : "\"begin\" expected",
      12 : "\"BEGIN\" expected",
      13 : "\"Begin\" expected",
      14 : "\"-\" expected",
      15 : "\"end\" expected",
      16 : "\"END\" expected",
      17 : "\"End\" expected",
      18 : "\"{\" expected",
      19 : "\"}\" expected",
      20 : "\"(\" expected",
      21 : "\")\" expected",
      22 : "\":\" expected",
      23 : "\"=\" expected",
      24 : "\",\" expected",
      25 : "\"\\\\}\" expected",
      26 : "\"or\" expected",
      27 : "\"xor\" expected",
      28 : "\"and\" expected",
      29 : "\"+\" expected",
      30 : "\"*\" expected",
      31 : "\"/\" expected",
      32 : "\"%\" expected",
      33 : "\"//\" expected",
      34 : "\"~\" expected",
      35 : "\"**\" expected",
      36 : "\"[\" expected",
      37 : "\"]\" expected",
      38 : "\"None\" expected",
      39 : "\"True\" expected",
      40 : "\"False\" expected",
      41 : "\".\" expected",
      42 : "??? expected",
      43 : "invalid string",
      44 : "this symbol not expected in Command",
      45 : "invalid Command",
      46 : "invalid CommandName",
      47 : "invalid BeginToken",
      48 : "invalid EndToken",
      49 : "invalid FactorTerm",
      50 : "invalid UnaryTerm",
      51 : "invalid PowerTerm",
      52 : "invalid AtomNonTrailableTerm",
      53 : "invalid AtomTrailableTerm",
      54 : "invalid TrailerTerm",
      55 : "invalid DictionaryElements",
      56 : "invalid DictionaryElements",
      57 : "invalid CallParametersElements",
      58 : "invalid CallParametersElements",
      59 : "invalid DictionaryElementKey",
      }


#-------------------------------------------------------------------------
#Parser.py -- ATG file parser
#Compiler Generator Coco/R,
#Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
#extended by M. Loeberbauer & A. Woess, Univ. of Linz
#ported from Java to Python by Ronald Longo
#
#This program is free software; you can redistribute it and/or modify it
#under the terms of the GNU General Public License as published by the
#Free Software Foundation; either version 2, or (at your option) any
#later version.
#
#This program is distributed in the hope that it will be useful, but
#WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
#or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
#for more details.
#
#You should have received a copy of the GNU General Public License along
#with this program; if not, write to the Free Software Foundation, Inc.,
#59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
#As an exception, it is allowed to write an extension of Coco/R that is
#used as a plugin in non-free software.
#
#If not otherwise stated, any source code generated by Coco/R (other than
#Coco/R itself) does not fall under the GNU General Public License.
#-------------------------------------------------------------------------*/

from Macro import Node

import sys




import sys

class Token( object ):
   def __init__( self ):
      self.kind   = 0     # token kind
      self.pos    = 0     # token position in the source text (starting at 0)
      self.col    = 0     # token column (starting at 0)
      self.line   = 0     # token line (starting at 1)
      self.val    = u''   # token value
      self.next   = None  # AW 2003-03-07 Tokens are kept in linked list


class Position( object ):    # position of source code stretch (e.g. semantic action, resolver expressions)
   def __init__( self, buf, beg, len, col ):
      assert isinstance( buf, Buffer )
      assert isinstance( beg, int )
      assert isinstance( len, int )
      assert isinstance( col, int )

      self.buf = buf
      self.beg = beg   # start relative to the beginning of the file
      self.len = len   # length of stretch
      self.col = col   # column number of start position

   def getSubstring( self ):
      return self.buf.readPosition( self )

class Buffer( object ):
   EOF      = u'\u0100'     # 256

   def __init__( self, s ):
      self.buf    = s
      self.bufLen = len(s)
      self.pos    = 0
      self.lines  = s.splitlines( True )

   def Read( self ):
      if self.pos < self.bufLen:
         result = self.buf[self.pos]
         self.pos += 1
         return result
      else:
         return Buffer.EOF

   def ReadChars( self, numBytes=1 ):
      result = self.buf[ self.pos : self.pos + numBytes ]
      self.pos += numBytes
      return result

   def Peek( self ):
      if self.pos < self.bufLen:
         return self.buf[self.pos]
      else:
         return Scanner.buffer.EOF

   def getString( self, beg, end ):
      s = ''
      oldPos = self.getPos( )
      self.setPos( beg )
      while beg < end:
         s += self.Read( )
         beg += 1
      self.setPos( oldPos )
      return s

   def getPos( self ):
      return self.pos

   def setPos( self, value ):
      if value < 0:
         self.pos = 0
      elif value >= self.bufLen:
         self.pos = self.bufLen
      else:
         self.pos = value

   def readPosition( self, pos ):
      assert isinstance( pos, Position )
      self.setPos( pos.beg )
      return self.ReadChars( pos.len )

   def __iter__( self ):
      return iter(self.lines)

class Scanner(object):
   EOL     = u'\n'
   eofSym  = 0

   charSetSize = 256
   maxT = 42
   noSym = 42
   start = [
     0,  0,  0,  0,  0,  0,  0,  0,  0,  3,  3,  3,  3,  0,  0,  0,
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
     3,  0,  8,  0,  0, 22,  0,  6, 15, 16, 30, 21, 19, 12, 28, 31,
     4,  4,  4,  4,  4,  4,  4,  4,  4,  4, 17,  0,  0, 18,  0,  0,
    11,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
     1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, 26, 29, 27,  0,  1,
     0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
     1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, 13,  0, 14, 24,  0,
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
     -1]


   def __init__( self, s ):
      self.buffer = Buffer( unicode(s) ) # the buffer instance

      self.ch        = u'\0'       # current input character
      self.pos       = -1          # column number of current character
      self.line      = 1           # line number of current character
      self.lineStart = 0           # start position of current line
      self.oldEols   = 0           # EOLs that appeared in a comment;
      self.NextCh( )
      self.ignore    = set( )      # set of characters to be ignored by the scanner
      #self.ignore.add( ord(' ') )  # blanks are always white space

      # fill token list
      self.tokens = Token( )       # the complete input token stream
      node   = self.tokens

      node.next = self.NextToken( )
      node = node.next
      while node.kind != Scanner.eofSym:
         node.next = self.NextToken( )
         node = node.next

      node.next = node
      node.val  = u'EOF'
      self.t  = self.tokens     # current token
      self.pt = self.tokens     # current peek token

   def NextCh( self ):
      if self.oldEols > 0:
         self.ch = Scanner.EOL
         self.oldEols -= 1
      else:
         self.ch = self.buffer.Read( )
         self.pos += 1
         # replace isolated '\r' by '\n' in order to make
         # eol handling uniform across Windows, Unix and Mac
         if (self.ch == u'\r') and (self.buffer.Peek() != u'\n'):
            self.ch = Scanner.EOL
         if self.ch == Scanner.EOL:
            self.line += 1
            self.lineStart = self.pos + 1
      



   def Comment0( self ):
      level = 1
      line0 = self.line
      lineStart0 = self.lineStart
      self.NextCh()
      if self.ch == '#':
         self.NextCh()
         while True:
            if ord(self.ch) == 10:
               level -= 1
               if level == 0:
                  self.oldEols = self.line - line0
                  self.NextCh()
                  return True
               self.NextCh()
            elif self.ch == Buffer.EOF:
               return False
            else:
               self.NextCh()
      else:
         if self.ch == Scanner.EOL:
            self.line -= 1
            self.lineStart = lineStart0
         self.pos = self.pos - 2
         self.buffer.setPos(self.pos+1)
         self.NextCh()
      return False


   def CheckLiteral( self ):
      lit = self.t.val
      if lit == "begin":
         self.t.kind = 11
      elif lit == "BEGIN":
         self.t.kind = 12
      elif lit == "Begin":
         self.t.kind = 13
      elif lit == "end":
         self.t.kind = 15
      elif lit == "END":
         self.t.kind = 16
      elif lit == "End":
         self.t.kind = 17
      elif lit == "or":
         self.t.kind = 26
      elif lit == "xor":
         self.t.kind = 27
      elif lit == "and":
         self.t.kind = 28
      elif lit == "None":
         self.t.kind = 38
      elif lit == "True":
         self.t.kind = 39
      elif lit == "False":
         self.t.kind = 40


   def NextToken( self ):
      while ord(self.ch) in self.ignore:
         self.NextCh( )
      if (self.ch == '@' and self.Comment0()):
         return self.NextToken()

      self.t = Token( )
      self.t.pos = self.pos
      self.t.col = self.pos - self.lineStart + 1
      self.t.line = self.line
      if ord(self.ch) < len(self.start):
         state = self.start[ord(self.ch)]
      else:
         state = 0
      buf = u''
      buf += unicode(self.ch)
      self.NextCh()

      done = False
      while not done:
         if state == -1:
            self.t.kind = Scanner.eofSym     # NextCh already done
            done = True
         elif state == 0:
            self.t.kind = Scanner.noSym      # NextCh already done
            done = True
         elif state == 1:
            if (self.ch >= '0' and self.ch <= '9'
                 or self.ch >= 'A' and self.ch <= 'Z'
                 or self.ch == '_'
                 or self.ch >= 'a' and self.ch <= 'z'):
               buf += unicode(self.ch)
               self.NextCh()
               state = 1
            else:
               self.t.kind = 1
               self.t.val = buf
               self.CheckLiteral()
               return self.t
         elif state == 2:
            if (self.ch >= '0' and self.ch <= '9'
                 or self.ch >= 'A' and self.ch <= 'Z'
                 or self.ch == '_'
                 or self.ch >= 'a' and self.ch <= 'z'):
               buf += unicode(self.ch)
               self.NextCh()
               state = 2
            else:
               self.t.kind = 3
               done = True
         elif state == 3:
            if (ord(self.ch) >= 9 and ord(self.ch) <= 12
                 or self.ch == ' '):
               buf += unicode(self.ch)
               self.NextCh()
               state = 3
            else:
               self.t.kind = 4
               done = True
         elif state == 4:
            if (self.ch >= '0' and self.ch <= '9'):
               buf += unicode(self.ch)
               self.NextCh()
               state = 4
            elif (self.ch >= 'A' and self.ch <= 'Z'
                 or self.ch == '_'
                 or self.ch >= 'a' and self.ch <= 'z'):
               buf += unicode(self.ch)
               self.NextCh()
               state = 2
            elif self.ch == '.':
               buf += unicode(self.ch)
               self.NextCh()
               state = 5
            else:
               self.t.kind = 2
               done = True
         elif state == 5:
            if (self.ch >= '0' and self.ch <= '9'):
               buf += unicode(self.ch)
               self.NextCh()
               state = 5
            elif (self.ch >= 'A' and self.ch <= 'Z'
                 or self.ch == '_'
                 or self.ch >= 'a' and self.ch <= 'z'):
               buf += unicode(self.ch)
               self.NextCh()
               state = 2
            else:
               self.t.kind = 2
               done = True
         elif state == 6:
            self.t.kind = 5
            done = True
         elif state == 7:
            self.t.kind = 6
            done = True
         elif state == 8:
            self.t.kind = 7
            done = True
         elif state == 9:
            self.t.kind = 8
            done = True
         elif state == 10:
            self.t.kind = 9
            done = True
         elif state == 11:
            self.t.kind = 10
            done = True
         elif state == 12:
            self.t.kind = 14
            done = True
         elif state == 13:
            self.t.kind = 18
            done = True
         elif state == 14:
            self.t.kind = 19
            done = True
         elif state == 15:
            self.t.kind = 20
            done = True
         elif state == 16:
            self.t.kind = 21
            done = True
         elif state == 17:
            self.t.kind = 22
            done = True
         elif state == 18:
            self.t.kind = 23
            done = True
         elif state == 19:
            self.t.kind = 24
            done = True
         elif state == 20:
            self.t.kind = 25
            done = True
         elif state == 21:
            self.t.kind = 29
            done = True
         elif state == 22:
            self.t.kind = 32
            done = True
         elif state == 23:
            self.t.kind = 33
            done = True
         elif state == 24:
            self.t.kind = 34
            done = True
         elif state == 25:
            self.t.kind = 35
            done = True
         elif state == 26:
            self.t.kind = 36
            done = True
         elif state == 27:
            self.t.kind = 37
            done = True
         elif state == 28:
            self.t.kind = 41
            done = True
         elif state == 29:
            if ord(self.ch) == 39:
               buf += unicode(self.ch)
               self.NextCh()
               state = 7
            elif self.ch == '"':
               buf += unicode(self.ch)
               self.NextCh()
               state = 9
            elif self.ch == '@':
               buf += unicode(self.ch)
               self.NextCh()
               state = 10
            elif self.ch == '}':
               buf += unicode(self.ch)
               self.NextCh()
               state = 20
            else:
               self.t.kind = Scanner.noSym
               done = True
         elif state == 30:
            if self.ch == '*':
               buf += unicode(self.ch)
               self.NextCh()
               state = 25
            else:
               self.t.kind = 30
               done = True
         elif state == 31:
            if self.ch == '/':
               buf += unicode(self.ch)
               self.NextCh()
               state = 23
            else:
               self.t.kind = 31
               done = True

      self.t.val = buf
      return self.t

   def Scan( self ):
      self.t = self.t.next
      self.pt = self.t.next
      return self.t

   def Peek( self ):
      self.pt = self.pt.next
      while self.pt.kind > self.maxT:
         self.pt = self.pt.next

      return self.pt

   def ResetPeek( self ):
      self.pt = self.t



class ErrorRec( object ):
   def __init__( self, l, c, s ):
      self.line   = l
      self.col    = c
      self.num    = 0
      self.str    = s


class Errors( object ):
   errMsgFormat = "file %(file)s : (%(line)d, %(col)d) %(text)s\n"
   eof          = False
   count        = 0         # number of errors detected
   fileName     = ''
   listName     = ''
   mergeErrors  = False
   mergedList   = None      # PrintWriter
   errors       = [ ]
   minErrDist   = 2
   errDist      = minErrDist
      # A function with prototype: f( errorNum=None ) where errorNum is a
      # predefined error number.  f returns a tuple, ( line, column, message )
      # such that line and column refer to the location in the
      # source file most recently parsed.  message is the error
      # message corresponging to errorNum.

   @staticmethod
   def Init( fn, dir, merge, getParsingPos, errorMessages ):
      Errors.theErrors = [ ]
      Errors.getParsingPos = getParsingPos
      Errors.errorMessages = errorMessages
      Errors.fileName = fn
      listName = dir + 'listing.txt'
      Errors.mergeErrors = merge
      if Errors.mergeErrors:
         try:
            Errors.mergedList = open( listName, 'w' )
         except IOError:
            raise RuntimeError( '-- Compiler Error: could not open ' + listName )

   @staticmethod
   def storeError( line, col, s ):
      if Errors.mergeErrors:
         Errors.errors.append( ErrorRec( line, col, s ) )
      else:
         Errors.printMsg( Errors.fileName, line, col, s )

   @staticmethod
   def SynErr( errNum, errPos=None ):
      line,col = errPos if errPos else Errors.getParsingPos( )
      msg = Errors.errorMessages[ errNum ]
      Errors.storeError( line, col, msg )
      Errors.count += 1

   @staticmethod
   def SemErr( errMsg, errPos=None ):
      line,col = errPos if errPos else Errors.getParsingPos( )
      Errors.storeError( line, col, errMsg )
      Errors.count += 1

   @staticmethod
   def Warn( errMsg, errPos=None ):
      line,col = errPos if errPos else Errors.getParsingPos( )
      Errors.storeError( line, col, errMsg )

   @staticmethod
   def Exception( errMsg ):
      print errMsg
      sys.exit( 1 )

   @staticmethod
   def printMsg( fileName, line, column, msg ):
      vals = { 'file':fileName, 'line':line, 'col':column, 'text':msg }
      sys.stdout.write( Errors.errMsgFormat % vals )

   @staticmethod
   def display( s, e ):
      Errors.mergedList.write('**** ')
      for c in xrange( 1, e.col ):
         if s[c-1] == '\t':
            Errors.mergedList.write( '\t' )
         else:
            Errors.mergedList.write( ' ' )
      Errors.mergedList.write( '^ ' + e.str + '\n')

   @staticmethod
   def Summarize( sourceBuffer ):
      if Errors.mergeErrors:
         # Initialize the line iterator
         srcLineIter = iter(sourceBuffer)
         srcLineStr  = srcLineIter.next( )
         srcLineNum  = 1

         try:
            # Initialize the error iterator
            errIter = iter(Errors.errors)
            errRec  = errIter.next( )

            # Advance to the source line of the next error
            while srcLineNum < errRec.line:
               Errors.mergedList.write( '%4d %s\n' % (srcLineNum, srcLineStr) )

               srcLineStr = srcLineIter.next( )
               srcLineNum += 1

            # Write out all errors for the current source line
            while errRec.line == srcLineNum:
               Errors.display( srcLineStr, errRec )

               errRec = errIter.next( )
         except:
            pass

         # No more errors to report
         try:
            # Advance to end of source file
            while True:
               Errors.mergedList.write( '%4d %s\n' % (srcLineNum, srcLineStr) )

               srcLineStr = srcLineIter.next( )
               srcLineNum += 1
         except:
            pass

         Errors.mergedList.write( '\n' )
         Errors.mergedList.write( '%d errors detected\n' % Errors.count )
         Errors.mergedList.close( )

      sys.stdout.write( '%d errors detected\n' % Errors.count )
      if (Errors.count > 0) and Errors.mergeErrors:
         sys.stdout.write( 'see ' + Errors.listName + '\n' )


class Parser( object ):
   _EOF = 0
   _identifier = 1
   _number = 2
   _numunit = 3
   _spaces = 4
   maxT = 42

   T          = True
   x          = False
   minErrDist = 2

   document = None
   def isCommandToken(self):
        token = self.token.next
        posttoken = self.token.next.next
        return token.val=="@" and posttoken.val not in ["end", "End", "END"]
   def isAnyToken(self):
        token = self.token.next
        print "TOKEN:", token.val
        

   def __init__( self ):
      self.scanner     = None
      self.token       = None           # last recognized token
      self.la          = None           # lookahead token
      self.genScanner  = False
      self.tokenString = ''             # used in declarations of literal tokens
      self.noString    = '-none-'       # used in declarations of literal tokens
      self.errDist     = Parser.minErrDist

   def getParsingPos( self ):
      return self.la.line, self.la.col

   def SynErr( self, errNum ):
      if self.errDist >= Parser.minErrDist:
         Errors.SynErr( errNum )

      self.errDist = 0

   def SemErr( self, msg ):
      if self.errDist >= Parser.minErrDist:
         Errors.SemErr( msg )

      self.errDist = 0

   def Warning( self, msg ):
      if self.errDist >= Parser.minErrDist:
         Errors.Warn( msg )

      self.errDist = 0

   def Successful( self ):
      return Errors.count == 0;

   def LexString( self ):
      return self.token.val

   def LookAheadString( self ):
      return self.la.val

   def Get( self ):
      while True:
         self.token = self.la
         self.la = self.scanner.Scan( )
         if self.la.kind <= Parser.maxT:
            self.errDist += 1
            break
         
         self.la = self.token

   def Expect( self, n ):
      if self.la.kind == n:
         self.Get( )
      else:
         self.SynErr( n )

   def StartOf( self, s ):
      return self.set[s][self.la.kind]

   def ExpectWeak( self, n, follow ):
      if self.la.kind == n:
         self.Get( )
      else:
         self.SynErr( n )
         while not self.StartOf(follow):
            self.Get( )

   def WeakSeparator( self, n, syFol, repFol ):
      s = [ False for i in xrange( Parser.maxT+1 ) ]
      if self.la.kind == n:
         self.Get( )
         return True
      elif self.StartOf(repFol):
         return False
      else:
         for i in xrange( Parser.maxT ):
            s[i] = self.set[syFol][i] or self.set[repFol][i] or self.set[0][i]
         self.SynErr( n )
         while not s[self.la.kind]:
            self.Get( )
         return self.StartOf( syFol )

   def string( self ):
      val = "" 
      if self.la.kind == 5:
         self.Get( )
         val += self.token.val 
         while self.StartOf(1):
            if self.StartOf(2):
               self.Get()
               val += self.token.val 
            elif self.la.kind == 4:
               self.Get( )
               val += self.token.val 
            else:
               self.Get( )
               val += self.token.val 

         self.Get( )
         val += self.token.val 
      elif self.la.kind == 7:
         self.Get( )
         val += self.token.val 
         while self.StartOf(3):
            if self.StartOf(4):
               self.Get()
               val += self.token.val 
            elif self.la.kind == 4:
               self.Get( )
               val += self.token.val 
            else:
               self.Get( )
               val += self.token.val 

         self.Get( )
         val += self.token.val 
      else:
         self.SynErr(43)
      return val

   def MacroSyntax( self ):
      doc = Node.CreateDocument(); cmd = None; txt = ""; 
      while self.StartOf(5):
         if self.la.kind == 10:
            cmd = self.Command()
            if txt != "": doc.AddTextChild(txt) 
            doc.AddChild(cmd); txt = "" 
         elif self.la.kind == 4:
            self.Get( )
            txt += self.token.val; 
         elif self.la.kind == 9:
            self.Get( )
            txt += "@"; 
         else:
            #if self.isAnyToken(): break 
            self.Get()
            txt += self.token.val; 

      self.Expect(0)
      if txt != "": doc.AddTextChild(txt) 
      self.document = doc; 
      #self.document.ViewTreeForm() 

   def Command( self ):
      cmd = None 
      self.Expect(10)
      while not (self.StartOf(6)):
         self.SynErr(44)
         self.Get()
      if (self.la.kind == 4):
         self.Get( )
      if self.la.kind == 1 or self.la.kind == 18:
         cmd = self.SimpleCommand()
      elif self.la.kind == 11 or self.la.kind == 12 or self.la.kind == 13:
         cmd = self.ExtendedCommand()
      else:
         self.SynErr(45)
      return cmd

   def SimpleCommand( self ):
      cmd = Node(); spaceval=""; textcmd = None
      temp = self.CommandName()
      cmd.name = temp.replace("_", "") 
      if (self.la.kind == 4):
         self.Get( )
         spaceval = self.token.val 
      if (self.la.kind == 20):
         self.ArgumentExpression(cmd)
         spaceval = "" 
      if (self.la.kind == 4):
         self.Get( )
         spaceval = self.token.val 
      if (self.la.kind == 18):
         self.TextArguments(cmd)
         spaceval = ""; 
      cmd.AddTextChild(spaceval); 
      return cmd

   def ExtendedCommand( self ):
      cmd = Node(); spaceval=""; textcmd = None; txt = ""
      self.BeginToken()
      if (self.la.kind == 4):
         self.Get( )
      temp = self.CommandName()
      cmd.name = temp.replace("_", ""); 
      if (self.la.kind == 4):
         self.Get( )
      if (self.la.kind == 20):
         self.ArgumentExpression(cmd)
      while self.StartOf(5):
         if self.StartOf(7):
            self.Get()
            txt += self.token.val; 
         elif self.la.kind == 4:
            self.Get( )
            txt += self.token.val; 
         elif self.la.kind == 9:
            self.Get( )
            txt += "@"; 
         else:
            if not self.isCommandToken(): break 
            temp = self.Command()
            if txt != "": cmd.AddTextChild(txt) 
            txt = ""; cmd.AddChild(temp); 

      if txt != "": cmd.AddTextChild(txt) 
      self.Expect(10)
      if (self.la.kind == 4):
         self.Get( )
      self.EndToken()
      return cmd

   def CommandName( self ):
      value = ""; id = "" 
      if self.la.kind == 1:
         id = self.Identifier()
         value += id 
      elif self.la.kind == 18:
         self.Get( )
         id = self.Identifier()
         value += id 
         self.Expect(19)
      else:
         self.SynErr(46)
      return value

   def ArgumentExpression( self, macro ):
      self.Expect(20)
      if (self.la.kind == 4):
         self.Get( )
      if (self.StartOf(8)):
         self.ArgumentParameters(macro)
      if (self.la.kind == 4):
         self.Get( )
      self.Expect(21)
      if (self.la.kind == 4):
         self.Get( )

   def TextArguments( self, cmd ):
      txt = ""
      self.Expect(18)
      if (self.la.kind == 4):
         self.Get( )
         txt += self.token.val; 
      while self.StartOf(9):
         if self.StartOf(10):
            self.Get()
            txt += self.token.val; 
         elif self.la.kind == 25:
            self.Get( )
            txt += self.token.val; 
         elif self.la.kind == 9:
            self.Get( )
            txt += "@"; 
         elif self.la.kind == 4:
            self.Get( )
            txt += self.token.val; 
         else:
            cmd = self.Command()
            if txt != "": cmd.AddTextChild(txt) 
            txt = ""; cmd.AddChild(cmd); 

      if txt != "": cmd.AddTextChild(txt) 
      self.Expect(19)

   def BeginToken( self ):
      if self.la.kind == 11:
         self.Get( )
      elif self.la.kind == 12:
         self.Get( )
      elif self.la.kind == 13:
         self.Get( )
      else:
         self.SynErr(47)
      if (self.la.kind == 4):
         self.Get( )
      self.Expect(14)

   def EndToken( self ):
      if self.la.kind == 15:
         self.Get( )
      elif self.la.kind == 16:
         self.Get( )
      elif self.la.kind == 17:
         self.Get( )
      else:
         self.SynErr(48)

   def Identifier( self ):
      value = "" 
      self.Expect(1)
      value += self.token.val 
      while self.la.kind == 14:
         self.Get( )
         value += "_" 
         self.Expect(1)
         value += self.token.val 

      return value

   def ArgumentParameters( self, macro ):
      uparams = []; nparams = {}; name=""; expr=""; 
      name = self.CommonExpression()
      uparams.append(name);  
      if (self.la.kind == 4):
         self.Get( )
      if (self.la.kind == 22 or self.la.kind == 23):
         if self.la.kind == 22:
            self.Get( )
         else:
            self.Get( )
         if (self.la.kind == 4):
            self.Get( )
         expr = self.CommonExpression()
         nparams[name] = expr; uparams.pop(); 
      if (self.la.kind == 4):
         self.Get( )
      while self.StartOf(11):
         while self.la.kind == 24:
            self.Get( )

         if (self.la.kind == 4):
            self.Get( )
         name = self.CommonExpression()
         uparams.append(name) 
         if (self.la.kind == 4):
            self.Get( )
         if (self.la.kind == 22 or self.la.kind == 23):
            if self.la.kind == 22:
               self.Get( )
            else:
               self.Get( )
            if (self.la.kind == 4):
               self.Get( )
            expr = self.CommonExpression()
            nparams[name] = expr; uparams.pop(); 
         if (self.la.kind == 4):
            self.Get( )

      if (self.la.kind == 4):
         self.Get( )
      for index, key in enumerate(uparams): nparams[index] = key 
      for key in nparams:
          attr = Node.CreateAttribute(); 
          attr.order = 0 
          attr.AddTextChild(nparams[key]) 
          macro.AddAttribute(str(key), attr) 

   def CommonExpression( self ):
      expression = ""; expr = ""; 
      expr = self.XorExpression()
      expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      while self.la.kind == 26:
         self.Get( )
         expression += " or "; 
         if (self.la.kind == 4):
            self.Get( )
         expr = self.XorExpression()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )

      if (self.la.kind == 4):
         self.Get( )
      return expression

   def XorExpression( self ):
      expression = ""; expr = ""; 
      expr = self.AndExpression()
      expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      while self.la.kind == 27:
         self.Get( )
         expression += " xor "; 
         if (self.la.kind == 4):
            self.Get( )
         expr = self.AndExpression()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )

      if (self.la.kind == 4):
         self.Get( )
      return expression

   def AndExpression( self ):
      expression = ""; expr = ""; 
      expr = self.ArithmeticExpression()
      expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      while self.la.kind == 28:
         self.Get( )
         expression += " and "; 
         if (self.la.kind == 4):
            self.Get( )
         expr = self.ArithmeticExpression()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )

      return expression

   def ArithmeticExpression( self ):
      expression = ""; expr = ""; 
      expr = self.TermExpression()
      expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      while self.la.kind == 14 or self.la.kind == 29:
         if self.la.kind == 29:
            self.Get( )
         else:
            self.Get( )
         expression += " " + self.token.val + " "; 
         if (self.la.kind == 4):
            self.Get( )
         expr = self.TermExpression()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )

      if (self.la.kind == 4):
         self.Get( )
      return expression

   def TermExpression( self ):
      expression = ""; expr = ""; 
      expr = self.FactorTerm()
      expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      while self.StartOf(12):
         if self.la.kind == 30:
            self.Get( )
         elif self.la.kind == 31:
            self.Get( )
         elif self.la.kind == 32:
            self.Get( )
         else:
            self.Get( )
         expression += " " + self.token.val +  " "; 
         if (self.la.kind == 4):
            self.Get( )
         expr = self.FactorTerm()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )

      if (self.la.kind == 4):
         self.Get( )
      return expression

   def FactorTerm( self ):
      expression = ""; expr = ""; 
      if self.la.kind == 14 or self.la.kind == 29 or self.la.kind == 34:
         expr = self.UnaryTerm()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )
      elif self.StartOf(13):
         expr = self.PowerTerm()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )
      else:
         self.SynErr(49)
      return expression

   def UnaryTerm( self ):
      expression = ""; expr = "";
      if self.la.kind == 29:
         self.Get( )
      elif self.la.kind == 14:
         self.Get( )
      elif self.la.kind == 34:
         self.Get( )
      else:
         self.SynErr(50)
      expression += " " + self.token.val + " "; 
      if (self.la.kind == 4):
         self.Get( )
      expr = self.FactorTerm()
      expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      return expression

   def PowerTerm( self ):
      expression = ""; expr = "";
      if self.StartOf(14):
         expr = self.MinimumTerm()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )
      elif self.StartOf(15):
         expr = self.AtomNonTrailableTerm()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )
      else:
         self.SynErr(51)
      return expression

   def MinimumTerm( self ):
      expression = ""; expr = ""; 
      expr = self.AtomTrailableTerm()
      expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      while self.la.kind == 20 or self.la.kind == 36 or self.la.kind == 41:
         expr = self.TrailerTerm()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )

      if (self.la.kind == 35):
         self.Get( )
         expression += " " + self.token.val + " "; 
         if (self.la.kind == 4):
            self.Get( )
         expr = self.FactorTerm()
         expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      return expression

   def AtomNonTrailableTerm( self ):
      expression = ""; expr = ""; 
      if self.la.kind == 2:
         self.Get( )
         expression += " " + self.token.val + " "; 
         if (self.la.kind == 4):
            self.Get( )
      elif self.la.kind == 3:
         self.Get( )
         expression += UnitNumber(self.token.val).EvalString() 
         if (self.la.kind == 4):
            self.Get( )
      elif self.la.kind == 38:
         self.Get( )
         expression += " " + self.token.val + " " 
         if (self.la.kind == 4):
            self.Get( )
      elif self.la.kind == 39:
         self.Get( )
         expression += " " + self.token.val + " " 
         if (self.la.kind == 4):
            self.Get( )
      elif self.la.kind == 40:
         self.Get( )
         expression += " " + self.token.val + " " 
         if (self.la.kind == 4):
            self.Get( )
      else:
         self.SynErr(52)
      return expression

   def AtomTrailableTerm( self ):
      expression = ""; expr = ""; 
      if self.la.kind == 36:
         expr = self.ListExpression()
         expression += expr; 
      elif self.la.kind == 18:
         expr = self.DictExpression()
         expression += expr; 
      elif self.la.kind == 20:
         expr = self.TupleExpression()
         expression += expr; 
      elif self.la.kind == 1:
         expr = self.Identifier()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )
      elif self.la.kind == 5 or self.la.kind == 7:
         expr = self.string()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )
      else:
         self.SynErr(53)
      return expression

   def TrailerTerm( self ):
      expression = ""; expr = ""; 
      if self.la.kind == 20:
         expr = self.CallExpression()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )
      elif self.la.kind == 36:
         expr = self.Indexer()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )
      elif self.la.kind == 41:
         self.Get( )
         expression += "."; 
         if (self.la.kind == 4):
            self.Get( )
         expr = self.Identifier()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )
      else:
         self.SynErr(54)
      return expression

   def ListExpression( self ):
      expression = ""; expr = ""; 
      self.Expect(36)
      expression += "["; 
      if (self.la.kind == 4):
         self.Get( )
      if (self.StartOf(8)):
         expr = self.ListElements()
         expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      self.Expect(37)
      expression += "]"; 
      return expression

   def ListElements( self ):
      expression = ""; expr = ""; 
      expr = self.CommonExpression()
      expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      while self.StartOf(11):
         while self.la.kind == 24:
            self.Get( )

         expression += ","; 
         if (self.la.kind == 4):
            self.Get( )
         expr = self.CommonExpression()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )

      if (self.la.kind == 4):
         self.Get( )
      while self.la.kind == 24:
         self.Get( )
         if (self.la.kind == 4):
            self.Get( )

      if (self.la.kind == 4):
         self.Get( )
      return expression

   def DictExpression( self ):
      expression = ""; expr = ""; 
      self.Expect(18)
      expression += "{"; 
      if (self.la.kind == 4):
         self.Get( )
      if (self.StartOf(16)):
         expr = self.DictionaryElements()
         expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      self.Expect(19)
      expression += "}"; 
      return expression

   def DictionaryElements( self ):
      expression = ""; expr = ""; 
      expr = self.DictionaryElementKey()
      expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      if self.la.kind == 22:
         self.Get( )
      elif self.la.kind == 23:
         self.Get( )
      else:
         self.SynErr(55)
      expression += ":"; 
      if (self.la.kind == 4):
         self.Get( )
      expr = self.CommonExpression()
      expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      while self.StartOf(17):
         while self.la.kind == 24:
            self.Get( )

         expression += ","; 
         if (self.la.kind == 4):
            self.Get( )
         expr = self.DictionaryElementKey()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )
         if self.la.kind == 22:
            self.Get( )
         elif self.la.kind == 23:
            self.Get( )
         else:
            self.SynErr(56)
         expression += ":"; 
         if (self.la.kind == 4):
            self.Get( )
         expr = self.CommonExpression()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )

      if (self.la.kind == 4):
         self.Get( )
      return expression

   def TupleExpression( self ):
      expression = ""; expr = ""; 
      self.Expect(20)
      expression += "("; 
      if (self.la.kind == 4):
         self.Get( )
      if (self.StartOf(8)):
         expr = self.ListElements()
         expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      self.Expect(21)
      expression += ")"; 
      return expression

   def CallParametersElements( self ):
      expression = ""; expr = ""; 
      expr = self.Identifier()
      expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      if self.la.kind == 22:
         self.Get( )
      elif self.la.kind == 23:
         self.Get( )
      else:
         self.SynErr(57)
      expression += ":"; 
      if (self.la.kind == 4):
         self.Get( )
      expr = self.CommonExpression()
      expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      while self.la.kind == 1 or self.la.kind == 4 or self.la.kind == 24:
         while self.la.kind == 24:
            self.Get( )

         expression += ","; 
         if (self.la.kind == 4):
            self.Get( )
         expr = self.Identifier()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )
         if self.la.kind == 22:
            self.Get( )
         elif self.la.kind == 23:
            self.Get( )
         else:
            self.SynErr(58)
         expression += ":"; 
         if (self.la.kind == 4):
            self.Get( )
         expr = self.CommonExpression()
         expression += expr; 
         if (self.la.kind == 4):
            self.Get( )

      if (self.la.kind == 4):
         self.Get( )
      return expression

   def DictionaryElementKey( self ):
      expression = ""; expr = ""; 
      if self.la.kind == 1:
         expr = self.Identifier()
         expression += repr(expr); 
      elif self.la.kind == 5 or self.la.kind == 7:
         expr = self.string()
         expression += expr; 
      elif self.la.kind == 2:
         self.Get( )
         expression += self.token.val; 
      else:
         self.SynErr(59)
      return expression

   def CallExpression( self ):
      expression = ""; expr = ""; 
      self.Expect(20)
      expression += "("; 
      if (self.la.kind == 4):
         self.Get( )
      if (self.StartOf(8)):
         expr = self.ListElements()
         expression += expr; 
      if (self.la.kind == 1):
         expr = self.CallParametersElements()
         expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      self.Expect(21)
      if (self.la.kind == 4):
         self.Get( )
      return expression

   def Indexer( self ):
      expression = ""; expr = ""; 
      self.Expect(36)
      expression += "["; 
      if (self.la.kind == 4):
         self.Get( )
      expr = self.SubscriptList()
      expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      self.Expect(37)
      expression += "]"; 
      if (self.la.kind == 4):
         self.Get( )
      return expression

   def SubscriptList( self ):
      expression = ""; expr = ""; 
      expr = self.SubscriptElement()
      expression += expr; 
      while self.StartOf(18):
         while self.la.kind == 24:
            self.Get( )

         expression += ","; 
         expr = self.SubscriptElement()
         expression += expr; 

      while self.la.kind == 24:
         self.Get( )

      return expression

   def SubscriptElement( self ):
      expression = ""; expr = ""; 
      expr = self.CommonExpression()
      expression += expr; 
      if (self.la.kind == 4):
         self.Get( )
      if (self.la.kind == 22):
         self.Get( )
         expression += ":"; 
         if (self.la.kind == 4):
            self.Get( )
         if (self.StartOf(8)):
            expr = self.CommonExpression()
            expression += expr; 
            if (self.la.kind == 4):
               self.Get( )
         if (self.la.kind == 22):
            self.Get( )
            expression += ":"; 
            if (self.la.kind == 4):
               self.Get( )
            if (self.StartOf(8)):
               expr = self.CommonExpression()
               expression += expr; 
               if (self.la.kind == 4):
                  self.Get( )
      return expression



   def Parse( self, scanner ):
      self.scanner = scanner
      self.la = Token( )
      self.la.val = u''
      self.Get( )
      self.MacroSyntax()
      self.Expect(0)


   set = [
      [T,T,x,x, T,x,x,x, x,x,x,T, T,T,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x],
      [x,T,T,T, T,x,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,x],
      [x,T,T,T, x,x,x,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,x],
      [x,T,T,T, T,T,T,x, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,x],
      [x,T,T,T, x,T,T,x, x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,x],
      [x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,x],
      [T,T,x,x, T,x,x,x, x,x,x,T, T,T,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x],
      [x,T,T,T, x,T,T,T, T,x,x,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,x],
      [x,T,T,T, x,T,x,T, x,x,x,x, x,x,T,x, x,x,T,x, T,x,x,x, x,x,x,x, x,T,x,x, x,x,T,x, T,x,T,T, T,x,x,x],
      [x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,x, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,x],
      [x,T,T,T, x,T,T,T, T,x,x,T, T,T,T,T, T,T,T,x, T,T,T,T, T,x,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,x],
      [x,T,T,T, T,T,x,T, x,x,x,x, x,x,T,x, x,x,T,x, T,x,x,x, T,x,x,x, x,T,x,x, x,x,T,x, T,x,T,T, T,x,x,x],
      [x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,T,x,x, x,x,x,x, x,x,x,x],
      [x,T,T,T, x,T,x,T, x,x,x,x, x,x,x,x, x,x,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,T,T, T,x,x,x],
      [x,T,x,x, x,T,x,T, x,x,x,x, x,x,x,x, x,x,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x],
      [x,x,T,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,x,x,x],
      [x,T,T,x, x,T,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x],
      [x,T,T,x, T,T,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x],
      [x,T,T,T, x,T,x,T, x,x,x,x, x,x,T,x, x,x,T,x, T,x,x,x, T,x,x,x, x,T,x,x, x,x,T,x, T,x,T,T, T,x,x,x]

      ]

   errorMessages = {
      
      0 : "EOF expected",
      1 : "identifier expected",
      2 : "number expected",
      3 : "numunit expected",
      4 : "spaces expected",
      5 : "\"\'\" expected",
      6 : "\"\\\\\'\" expected",
      7 : "\"\"\" expected",
      8 : "\"\\\\\"\" expected",
      9 : "\"\\\\@\" expected",
      10 : "\"@\" expected",
      11 : "\"begin\" expected",
      12 : "\"BEGIN\" expected",
      13 : "\"Begin\" expected",
      14 : "\"-\" expected",
      15 : "\"end\" expected",
      16 : "\"END\" expected",
      17 : "\"End\" expected",
      18 : "\"{\" expected",
      19 : "\"}\" expected",
      20 : "\"(\" expected",
      21 : "\")\" expected",
      22 : "\":\" expected",
      23 : "\"=\" expected",
      24 : "\",\" expected",
      25 : "\"\\\\}\" expected",
      26 : "\"or\" expected",
      27 : "\"xor\" expected",
      28 : "\"and\" expected",
      29 : "\"+\" expected",
      30 : "\"*\" expected",
      31 : "\"/\" expected",
      32 : "\"%\" expected",
      33 : "\"//\" expected",
      34 : "\"~\" expected",
      35 : "\"**\" expected",
      36 : "\"[\" expected",
      37 : "\"]\" expected",
      38 : "\"None\" expected",
      39 : "\"True\" expected",
      40 : "\"False\" expected",
      41 : "\".\" expected",
      42 : "??? expected",
      43 : "invalid string",
      44 : "this symbol not expected in Command",
      45 : "invalid Command",
      46 : "invalid CommandName",
      47 : "invalid BeginToken",
      48 : "invalid EndToken",
      49 : "invalid FactorTerm",
      50 : "invalid UnaryTerm",
      51 : "invalid PowerTerm",
      52 : "invalid AtomNonTrailableTerm",
      53 : "invalid AtomTrailableTerm",
      54 : "invalid TrailerTerm",
      55 : "invalid DictionaryElements",
      56 : "invalid DictionaryElements",
      57 : "invalid CallParametersElements",
      58 : "invalid CallParametersElements",
      59 : "invalid DictionaryElementKey",
      }


