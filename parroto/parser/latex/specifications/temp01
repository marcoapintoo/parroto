from Scanner import Position

class ErrorRec( object ):
   def __init__( self, l, c, s ):
      self.line   = l
      self.col    = c
      self.num    = 0
      self.str    = s


class Errors( object ):
   errMsgFormat = "file %(file)s : (%(line)d, %(col)d) %(text)s\n"
   eof          = False
   count        = 0         # number of errors detected
   fileName     = ''
   listName     = ''
   mergeErrors  = False
   mergedList   = None      # PrintWriter
   errors       = [ ]
   minErrDist   = 2
   errDist      = minErrDist
      # A function with prototype: f( errorNum=None ) where errorNum is a
      # predefined error number.  f returns a tuple, ( line, column, message )
      # such that line and column refer to the location in the
      # source file most recently parsed.  message is the error
      # message corresponging to errorNum.

   @staticmethod
   def Init( fn, dir, merge, getParsingPos, errorMessages ):
      Errors.theErrors = [ ]
      Errors.getParsingPos = getParsingPos
      Errors.errorMessages = errorMessages
      Errors.fileName = fn
      listName = dir + 'listing.txt'
      Errors.mergeErrors = merge
      if Errors.mergeErrors:
         try:
            Errors.mergedList = open( listName, 'w' )
         except IOError:
            raise RuntimeError( '-- Compiler Error: could not open ' + listName )

   @staticmethod
   def storeError( line, col, s ):
      if Errors.mergeErrors:
         Errors.errors.append( ErrorRec( line, col, s ) )
      else:
         Errors.printMsg( Errors.fileName, line, col, s )

   @staticmethod
   def SynErr( errNum, errPos=None ):
      line,col = errPos if errPos else Errors.getParsingPos( )
      msg = Errors.errorMessages[ errNum ]
      Errors.storeError( line, col, msg )
      Errors.count += 1

   @staticmethod
   def SemErr( errMsg, errPos=None ):
      line,col = errPos if errPos else Errors.getParsingPos( )
      Errors.storeError( line, col, errMsg )
      Errors.count += 1

   @staticmethod
   def Warn( errMsg, errPos=None ):
      line,col = errPos if errPos else Errors.getParsingPos( )
      Errors.storeError( line, col, errMsg )

   @staticmethod
   def Exception( errMsg ):
      print errMsg
      sys.exit( 1 )

   @staticmethod
   def printMsg( fileName, line, column, msg ):
      vals = { 'file':fileName, 'line':line, 'col':column, 'text':msg }
      sys.stdout.write( Errors.errMsgFormat % vals )

   @staticmethod
   def display( s, e ):
      Errors.mergedList.write('**** ')
      for c in xrange( 1, e.col ):
         if s[c-1] == '\t':
            Errors.mergedList.write( '\t' )
         else:
            Errors.mergedList.write( ' ' )
      Errors.mergedList.write( '^ ' + e.str + '\n')

   @staticmethod
   def Summarize( sourceBuffer ):
      if Errors.mergeErrors:
         # Initialize the line iterator
         srcLineIter = iter(sourceBuffer)
         srcLineStr  = srcLineIter.next( )
         srcLineNum  = 1

         try:
            # Initialize the error iterator
            errIter = iter(Errors.errors)
            errRec  = errIter.next( )

            # Advance to the source line of the next error
            while srcLineNum < errRec.line:
               Errors.mergedList.write( '%4d %s\n' % (srcLineNum, srcLineStr) )

               srcLineStr = srcLineIter.next( )
               srcLineNum += 1

            # Write out all errors for the current source line
            while errRec.line == srcLineNum:
               Errors.display( srcLineStr, errRec )

               errRec = errIter.next( )
         except:
            pass

         # No more errors to report
         try:
            # Advance to end of source file
            while True:
               Errors.mergedList.write( '%4d %s\n' % (srcLineNum, srcLineStr) )

               srcLineStr = srcLineIter.next( )
               srcLineNum += 1
         except:
            pass

         Errors.mergedList.write( '\n' )
         Errors.mergedList.write( '%d errors detected\n' % Errors.count )
         Errors.mergedList.close( )

      sys.stdout.write( '%d errors detected\n' % Errors.count )
      if (Errors.count > 0) and Errors.mergeErrors:
         sys.stdout.write( 'see ' + Errors.listName + '\n' )


class Parser( object ):
   _EOF = 0
   _symbols = 1
   _identifier = 2
   _number = 3
   _numunit = 4
   _spaces = 5
   _string1 = 6
   _string2 = 7
   maxT = 27

   T          = True
   x          = False
   minErrDist = 2

   document = None
   def isCommandToken(self):
       token = self.token.next
       posttoken = self.token.next.next
       return token.val=="\\" and posttoken.val not in ["stop", "Stop", "STOP"]
				

   def __init__( self ):
      self.scanner     = None
      self.token       = None           # last recognized token
      self.la          = None           # lookahead token
      self.genScanner  = False
      self.tokenString = ''             # used in declarations of literal tokens
      self.noString    = '-none-'       # used in declarations of literal tokens
      self.errDist     = Parser.minErrDist

   def getParsingPos( self ):
      return self.la.line, self.la.col

   def SynErr( self, errNum ):
      if self.errDist >= Parser.minErrDist:
         Errors.SynErr( errNum )

      self.errDist = 0

   def SemErr( self, msg ):
      if self.errDist >= Parser.minErrDist:
         Errors.SemErr( msg )

      self.errDist = 0

   def Warning( self, msg ):
      if self.errDist >= Parser.minErrDist:
         Errors.Warn( msg )

      self.errDist = 0

   def Successful( self ):
      return Errors.count == 0;

   def LexString( self ):
      return self.token.val

   def LookAheadString( self ):
      return self.la.val

   def Get( self ):
      while True:
         self.token = self.la
         self.la = self.scanner.Scan( )
         if self.la.kind <= Parser.maxT:
            self.errDist += 1
            break
         
         self.la = self.token

   def Expect( self, n ):
      if self.la.kind == n:
         self.Get( )
      else:
         self.SynErr( n )

   def StartOf( self, s ):
      return self.set[s][self.la.kind]

   def ExpectWeak( self, n, follow ):
      if self.la.kind == n:
         self.Get( )
      else:
         self.SynErr( n )
         while not self.StartOf(follow):
            self.Get( )

   def WeakSeparator( self, n, syFol, repFol ):
      s = [ False for i in xrange( Parser.maxT+1 ) ]
      if self.la.kind == n:
         self.Get( )
         return True
      elif self.StartOf(repFol):
         return False
      else:
         for i in xrange( Parser.maxT ):
            s[i] = self.set[syFol][i] or self.set[repFol][i] or self.set[0][i]
         self.SynErr( n )
         while not s[self.la.kind]:
            self.Get( )
         return self.StartOf( syFol )

   def AnyTextChar( self ):
      val = u"" 
      if self.la.kind == 2:
         self.Get( )
         val += self.token.val 
      elif self.la.kind == 3:
         self.Get( )
         val += self.token.val 
      elif self.la.kind == 1:
         self.Get( )
         val += self.token.val 
      elif self.la.kind == 8:
         self.Get( )
         val += self.token.val 
      else:
         self.SynErr(28)
      return val

   def TextString( self ):
      val = u"" 
      if self.la.kind == 6:
         self.Get( )
         val += eval("u"+self.token.val); 
      elif self.la.kind == 7:
         self.Get( )
         val += eval("u"+self.token.val); 
      elif self.la.kind == 9:
         self.Get( )
         while self.StartOf(1):
            if self.StartOf(2):
               self.Get()
               val += self.token.val 
            elif self.la.kind == 5:
               self.Get( )
               val += self.token.val 
            elif self.la.kind == 10:
               self.Get( )
               val += '}' 
            else:
               self.Get( )
               val += '%' 

         self.Expect(12)
      elif self.StartOf(3):
         val = self.AnyTextChar()
         v = u""; 
         while self.StartOf(3):
            v = self.AnyTextChar()
            val += v; 

      else:
         self.SynErr(29)
      return val

   def Syntax( self ):
      cmd = u""; txt = u""; 
      while self.StartOf(4):
         if self.la.kind == 14:
            cmd = self.Command()
            txt += cmd 
         elif self.la.kind == 5:
            self.Get( )
            txt += self.token.val; 
         elif self.la.kind == 13:
            self.Get( )
            txt += u"\\"; 
         else:
            self.Get()
            txt += self.token.val; 

      self.Expect(0)
      self.document = u"<document-file>{0}</document-file>".format(txt); 

   def Command( self ):
      cmd = u"" 
      self.Expect(14)
      while not (self.StartOf(5)):
         self.SynErr(30)
         self.Get()
      if (self.la.kind == 5):
         self.Get( )
      if self.la.kind == 2 or self.la.kind == 9:
         cmd = self.SimpleCommand()
      elif self.la.kind == 15 or self.la.kind == 16 or self.la.kind == 17:
         cmd = self.ExtendedCommand()
      else:
         self.SynErr(31)
      return cmd

   def SimpleCommand( self ):
      cmd = u""; name = u""; args = u""; content = u""; spaceval="";
      name = self.CommandName()
      name = name.replace("_", "").lower() 
      if (self.la.kind == 5):
         self.Get( )
         spaceval = self.token.val 
      if (self.la.kind == 21):
         args = self.ArgumentExpression()
         spaceval = u"" 
      if (self.la.kind == 5):
         self.Get( )
         spaceval = self.token.val 
      if (self.la.kind == 9):
         content = self.TextArguments()
         spaceval = u""; 
      cmd = u"<{name} {args}>{content}</{name}>{spaceval}".format(name=name, args=args, content=content, spaceval=spaceval) 
      return cmd

   def ExtendedCommand( self ):
      cmd = u""; name = u""; args = u""; content = u""; 
      self.BeginToken()
      if (self.la.kind == 5):
         self.Get( )
      name = self.CommandName()
      name = name.replace("_", "").lower() 
      if (self.la.kind == 5):
         self.Get( )
         content = self.token.val 
      if (self.la.kind == 21):
         args = self.ArgumentExpression()
         content = u"" 
      while self.StartOf(4):
         if self.StartOf(6):
            self.Get()
            content += self.token.val; 
         elif self.la.kind == 5:
            self.Get( )
            content += self.token.val; 
         elif self.la.kind == 13:
            self.Get( )
            content += u"\\"; 
         else:
            if not self.isCommandToken(): break 
            cmd = self.Command()
            content += cmd 

      cmd = u"<{name} {args}>{content}</{name}>".format(name=name, args=args, content=content) 
      self.Expect(14)
      if (self.la.kind == 5):
         self.Get( )
      self.EndToken()
      return cmd

   def CommandName( self ):
      value = u""; id = u"" 
      if self.la.kind == 2:
         id = self.Identifier()
         value += id 
      elif self.la.kind == 9:
         self.Get( )
         id = self.Identifier()
         value += id 
         self.Expect(12)
      else:
         self.SynErr(32)
      return value

   def ArgumentExpression( self ):
      self.Expect(21)
      if (self.la.kind == 5):
         self.Get( )
      if (self.StartOf(7)):
         macro = self.ArgumentParameters()
      if (self.la.kind == 5):
         self.Get( )
      self.Expect(22)
      return macro

   def TextArguments( self ):
      txt = u""
      self.Expect(9)
      if (self.la.kind == 5):
         self.Get( )
         txt += self.token.val; 
      while self.StartOf(1):
         if self.StartOf(8):
            self.Get()
            txt += self.token.val; 
         elif self.la.kind == 10:
            self.Get( )
            txt += self.token.val; 
         elif self.la.kind == 13:
            self.Get( )
            txt += u"\\"; 
         elif self.la.kind == 11:
            self.Get( )
            txt += u"%"; 
         elif self.la.kind == 5:
            self.Get( )
            txt += self.token.val; 
         else:
            cmd = self.Command()
            txt += cmd 

      self.Expect(12)
      return txt

   def BeginToken( self ):
      if self.la.kind == 15:
         self.Get( )
      elif self.la.kind == 16:
         self.Get( )
      elif self.la.kind == 17:
         self.Get( )
      else:
         self.SynErr(33)
      if (self.la.kind == 5):
         self.Get( )
      self.Expect(8)

   def EndToken( self ):
      if self.la.kind == 18:
         self.Get( )
      elif self.la.kind == 19:
         self.Get( )
      elif self.la.kind == 20:
         self.Get( )
      else:
         self.SynErr(34)

   def Identifier( self ):
      value = u"" 
      self.Expect(2)
      value += self.token.val 
      while self.la.kind == 8 or self.la.kind == 26:
         if self.la.kind == 8:
            self.Get( )
            value += u"-" 
         else:
            self.Get( )
            value += u"." 
         self.Expect(2)
         value += self.token.val 

      return value

   def ArgumentParameters( self ):
      arg = u""; args = u""; index = 0; 
      arg = self.ArgumentParameter(index)
      index += (1 if arg.startswith("argument-") else 0); args += arg; 
      if (self.la.kind == 5):
         self.Get( )
      while self.StartOf(9):
         while self.la.kind == 25:
            self.Get( )

         if (self.la.kind == 5):
            self.Get( )
         arg = self.ArgumentParameter(index)
         index += (1 if arg.startswith("argument-") else 0); args += arg; 
         if (self.la.kind == 5):
            self.Get( )

      if (self.la.kind == 5):
         self.Get( )
      return args

   def ArgumentParameter( self, index ):
      arg = u""; args = u""; temp = u""; name = u"argument-{0}".format(index); 
      args = self.TextString()
      if (self.la.kind == 5):
         self.Get( )
      if (self.la.kind == 23 or self.la.kind == 24):
         if self.la.kind == 23:
            self.Get( )
         else:
            self.Get( )
         if (self.la.kind == 5):
            self.Get( )
         temp = self.TextString()
         name, args = args, temp; 
         if not name.replace("-","").isalnum(): raise Exception("Invalid parameter name "+name); 
      arg = u'{name}="{args}" '.format(name = name, args = args); 
      return arg



   def Parse( self, scanner ):
      self.scanner = scanner
      self.la = Token( )
      self.la.val = u''
      self.Get( )
      self.Syntax()
      self.Expect(0)


   set = [
      [T,x,T,x, x,T,x,x, x,T,x,x, x,x,x,T, T,T,x,x, x,x,x,x, x,x,x,x, x],
      [x,T,T,T, T,T,T,T, T,T,T,T, x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, x],
      [x,T,T,T, T,x,T,T, T,T,x,x, x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, x],
      [x,T,T,T, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x],
      [x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, x],
      [T,x,T,x, x,T,x,x, x,T,x,x, x,x,x,T, T,T,x,x, x,x,x,x, x,x,x,x, x],
      [x,T,T,T, T,x,T,T, T,T,T,T, T,x,x,T, T,T,T,T, T,T,T,T, T,T,T,T, x],
      [x,T,T,T, x,x,T,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x],
      [x,T,T,T, T,x,T,T, T,T,x,x, x,x,x,T, T,T,T,T, T,T,T,T, T,T,T,T, x],
      [x,T,T,T, x,T,T,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x]

      ]

   errorMessages = {
      
      0 : "EOF expected",
      1 : "symbols expected",
      2 : "identifier expected",
      3 : "number expected",
      4 : "numunit expected",
      5 : "spaces expected",
      6 : "string1 expected",
      7 : "string2 expected",
      8 : "\"-\" expected",
      9 : "\"{\" expected",
      10 : "\"\\\\}\" expected",
      11 : "\"\\\\%\" expected",
      12 : "\"}\" expected",
      13 : "\"\\\\\\\\\" expected",
      14 : "\"\\\\\" expected",
      15 : "\"start\" expected",
      16 : "\"Start\" expected",
      17 : "\"START\" expected",
      18 : "\"stop\" expected",
      19 : "\"Stop\" expected",
      20 : "\"STOP\" expected",
      21 : "\"[\" expected",
      22 : "\"]\" expected",
      23 : "\":\" expected",
      24 : "\"=\" expected",
      25 : "\",\" expected",
      26 : "\".\" expected",
      27 : "??? expected",
      28 : "invalid AnyTextChar",
      29 : "invalid TextString",
      30 : "this symbol not expected in Command",
      31 : "invalid Command",
      32 : "invalid CommandName",
      33 : "invalid BeginToken",
      34 : "invalid EndToken",
      }


